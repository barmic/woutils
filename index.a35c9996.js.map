{"mappings":"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","sources":["<anon>","src/app.ts","src/AwesomeBar.ts","src/BoxRespons.ts","src/Response.ts","src/tools/Numbers.ts","node_modules/emoji-picker-element/index.js","node_modules/emoji-picker-element/picker.js","node_modules/emoji-picker-element/database.js"],"sourcesContent":["class $6bcec25060dd6e92$export$395e24b9a277a1da extends HTMLElement {\n    query;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: \"open\"\n        });\n    }\n    connectedCallback() {\n        this.shadowRoot.innerHTML = `\n        <style>\n        *,\n        *::before,\n        *::after { \n          box-sizing: border-box;\n        }\n        \n        .input-sizer {\n          display: inline-grid;\n          vertical-align: top;\n          align-items: center;\n          position: relative;\n          border-radius: 10px;\n          padding: .25em .5em;\n          margin: 5px;\n          background-color: var(--nord3);\n          \n          &.stacked {\n            padding: .5em;\n            align-items: stretch;\n            \n            &::after,\n            input,\n            textarea {\n              grid-area: 2 / 1;\n              color: var(--nord6);\n            }\n          }\n          \n          &::after,\n          input,\n          textarea {\n            width: auto;\n            min-width: 1em;\n            grid-area: 1 / 2;\n            font: inherit;\n            padding: 0.25em;\n            margin: 0;\n            resize: none;\n            background: none;\n            appearance: none;\n            border: none;\n          }\n          \n          span {\n            padding: 0.25em;\n          }\n          \n          &::after {\n            content: attr(data-value) ' ';\n            visibility: hidden;\n            white-space: pre-wrap;\n          }\n        }\n        \n        .input-sizer {\n          > span {\n            text-transform: uppercase;\n            font-size: 0.8em;\n            font-weight: bold;\n          }\n        }\n        </style>\n        <div class=\"input-sizer stacked\">\n        <label for=\"name\">Quoi\\u{202F}?</label>\n        <textarea oninput=\"this.parentNode.dataset.value = this.value\" rows=\"1\" id=\"name\" name=\"name\"></textarea>\n        </div>`;\n        const input = this.shadowRoot.querySelector(\"textarea\");\n        const debounce = (callback, wait)=>{\n            let timeoutId = null;\n            return (...args)=>{\n                window.clearTimeout(timeoutId);\n                timeoutId = window.setTimeout(()=>callback.apply(null, args), wait);\n            };\n        };\n        const handleMouseMove = debounce(()=>{\n            this.dispatchEvent(new CustomEvent(\"change\", {\n                detail: input.value\n            }));\n        }, 250);\n        input.addEventListener(\"input\", handleMouseMove);\n        input.focus();\n    }\n    get value() {\n        let textbox = this.shadowRoot.querySelector(\"input\");\n        return textbox.value;\n    }\n}\n\n\nconst $7c9734ca8f93e03f$var$template = document.createElement(\"template\");\n$7c9734ca8f93e03f$var$template.innerHTML = `\n<style>\ndiv {\n  background-color: var(--nord3);\n  height: 400px;\n  width: 344px;\n  border: 1px;\n  border-radius: 15px;\n  padding: 1ex;\n}\n</style>\n<div><slot></slot></div>`;\nclass $7c9734ca8f93e03f$export$46209ca0040d6ae6 extends HTMLElement {\n    query;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: \"open\"\n        });\n    }\n    connectedCallback() {\n        this.shadowRoot.appendChild($7c9734ca8f93e03f$var$template.content.cloneNode(true));\n    }\n}\n\n\nclass $a4d41102f2c043db$export$bc00d4d99d9c6e7d extends HTMLElement {\n    query;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: \"open\"\n        });\n    }\n    connectedCallback() {\n        const query = this.parse(this.getAttribute(\"query\"));\n        Intl.NumberFormat;\n        this.shadowRoot.innerHTML = `\n            <div>\n                <h2>Number</h2>\n                <dl>\n                    <dt>${query}</dt>\n                    <dd>decimal</dd>\n\n                    <dt>0x${query.toString(16)}</dt>\n                    <dd>hexa</dd>\n\n                    <dt>O${query.toString(2)}</dt>\n                    <dd>binary</dd>\n\n                    <dt>0b${query.toString(8)}</dt>\n                    <dd>octal</dd>\n                </dl>\n            </div>`;\n    }\n    parse(input) {\n        for (const base of [\n            10,\n            16,\n            2,\n            8\n        ]){\n            const r = parseInt(input, base);\n            if (!Number.isNaN(r)) return r;\n        }\n        return parseFloat(input);\n    }\n    static get observedAttributes() {\n        return [\n            \"query\"\n        ];\n    }\n    static accept(value) {\n        return /^[0-9a-fA-F,. ]+$/.test(value);\n    }\n    static elmentName() {\n        return \"mba-tools-numbers\";\n    }\n    attributeChangedCallback(name, _oldValue, newValue) {\n        if (name === \"query\") console.log(\"query\", newValue);\n    }\n}\n\n\nfunction $f19b912d87716459$var$assertNonEmptyString(str) {\n    if (typeof str !== \"string\" || !str) throw new Error(\"expected a non-empty string, got: \" + str);\n}\nfunction $f19b912d87716459$var$assertNumber(number) {\n    if (typeof number !== \"number\") throw new Error(\"expected a number, got: \" + number);\n}\nconst $f19b912d87716459$var$DB_VERSION_CURRENT = 1;\nconst $f19b912d87716459$var$DB_VERSION_INITIAL = 1;\nconst $f19b912d87716459$var$STORE_EMOJI = \"emoji\";\nconst $f19b912d87716459$var$STORE_KEYVALUE = \"keyvalue\";\nconst $f19b912d87716459$var$STORE_FAVORITES = \"favorites\";\nconst $f19b912d87716459$var$FIELD_TOKENS = \"tokens\";\nconst $f19b912d87716459$var$INDEX_TOKENS = \"tokens\";\nconst $f19b912d87716459$var$FIELD_UNICODE = \"unicode\";\nconst $f19b912d87716459$var$INDEX_COUNT = \"count\";\nconst $f19b912d87716459$var$FIELD_GROUP = \"group\";\nconst $f19b912d87716459$var$FIELD_ORDER = \"order\";\nconst $f19b912d87716459$var$INDEX_GROUP_AND_ORDER = \"group-order\";\nconst $f19b912d87716459$var$KEY_ETAG = \"eTag\";\nconst $f19b912d87716459$var$KEY_URL = \"url\";\nconst $f19b912d87716459$var$KEY_PREFERRED_SKINTONE = \"skinTone\";\nconst $f19b912d87716459$var$MODE_READONLY = \"readonly\";\nconst $f19b912d87716459$var$MODE_READWRITE = \"readwrite\";\nconst $f19b912d87716459$var$INDEX_SKIN_UNICODE = \"skinUnicodes\";\nconst $f19b912d87716459$var$FIELD_SKIN_UNICODE = \"skinUnicodes\";\nconst $f19b912d87716459$var$DEFAULT_DATA_SOURCE = \"https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json\";\nconst $f19b912d87716459$var$DEFAULT_LOCALE = \"en\";\n// like lodash's uniqBy but much smaller\nfunction $f19b912d87716459$var$uniqBy(arr, func) {\n    const set = new Set();\n    const res = [];\n    for (const item of arr){\n        const key = func(item);\n        if (!set.has(key)) {\n            set.add(key);\n            res.push(item);\n        }\n    }\n    return res;\n}\nfunction $f19b912d87716459$var$uniqEmoji(emojis) {\n    return $f19b912d87716459$var$uniqBy(emojis, (_)=>_.unicode);\n}\nfunction $f19b912d87716459$var$initialMigration(db) {\n    function createObjectStore(name, keyPath, indexes) {\n        const store = keyPath ? db.createObjectStore(name, {\n            keyPath: keyPath\n        }) : db.createObjectStore(name);\n        if (indexes) for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes))store.createIndex(indexName, keyPath, {\n            multiEntry: multiEntry\n        });\n        return store;\n    }\n    createObjectStore($f19b912d87716459$var$STORE_KEYVALUE);\n    createObjectStore($f19b912d87716459$var$STORE_EMOJI, /* keyPath */ $f19b912d87716459$var$FIELD_UNICODE, {\n        [$f19b912d87716459$var$INDEX_TOKENS]: [\n            $f19b912d87716459$var$FIELD_TOKENS,\n            /* multiEntry */ true\n        ],\n        [$f19b912d87716459$var$INDEX_GROUP_AND_ORDER]: [\n            [\n                $f19b912d87716459$var$FIELD_GROUP,\n                $f19b912d87716459$var$FIELD_ORDER\n            ]\n        ],\n        [$f19b912d87716459$var$INDEX_SKIN_UNICODE]: [\n            $f19b912d87716459$var$FIELD_SKIN_UNICODE,\n            /* multiEntry */ true\n        ]\n    });\n    createObjectStore($f19b912d87716459$var$STORE_FAVORITES, undefined, {\n        [$f19b912d87716459$var$INDEX_COUNT]: [\n            \"\"\n        ]\n    });\n}\nconst $f19b912d87716459$var$openIndexedDBRequests = {};\nconst $f19b912d87716459$var$databaseCache = {};\nconst $f19b912d87716459$var$onCloseListeners = {};\nfunction $f19b912d87716459$var$handleOpenOrDeleteReq(resolve, reject, req) {\n    // These things are almost impossible to test with fakeIndexedDB sadly\n    /* istanbul ignore next */ req.onerror = ()=>reject(req.error);\n    /* istanbul ignore next */ req.onblocked = ()=>reject(new Error(\"IDB blocked\"));\n    req.onsuccess = ()=>resolve(req.result);\n}\nasync function $f19b912d87716459$var$createDatabase(dbName) {\n    const db = await new Promise((resolve, reject)=>{\n        const req = indexedDB.open(dbName, $f19b912d87716459$var$DB_VERSION_CURRENT);\n        $f19b912d87716459$var$openIndexedDBRequests[dbName] = req;\n        req.onupgradeneeded = (e)=>{\n            // Technically there is only one version, so we don't need this `if` check\n            // But if an old version of the JS is in another browser tab\n            // and it gets upgraded in the future and we have a new DB version, well...\n            // better safe than sorry.\n            /* istanbul ignore else */ if (e.oldVersion < $f19b912d87716459$var$DB_VERSION_INITIAL) $f19b912d87716459$var$initialMigration(req.result);\n        };\n        $f19b912d87716459$var$handleOpenOrDeleteReq(resolve, reject, req);\n    });\n    // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n    // No need for removeEventListener, because once the DB can no longer\n    // fire \"close\" events, it will auto-GC.\n    // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n    /* istanbul ignore next */ db.onclose = ()=>$f19b912d87716459$var$closeDatabase(dbName);\n    return db;\n}\nfunction $f19b912d87716459$var$openDatabase(dbName) {\n    if (!$f19b912d87716459$var$databaseCache[dbName]) $f19b912d87716459$var$databaseCache[dbName] = $f19b912d87716459$var$createDatabase(dbName);\n    return $f19b912d87716459$var$databaseCache[dbName];\n}\nfunction $f19b912d87716459$var$dbPromise(db, storeName, readOnlyOrReadWrite, cb) {\n    return new Promise((resolve, reject)=>{\n        // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n        // are really irreplaceable data. IndexedDB is just a cache in this case.\n        const txn = db.transaction(storeName, readOnlyOrReadWrite, {\n            durability: \"relaxed\"\n        });\n        const store = typeof storeName === \"string\" ? txn.objectStore(storeName) : storeName.map((name)=>txn.objectStore(name));\n        let res;\n        cb(store, txn, (result)=>{\n            res = result;\n        });\n        txn.oncomplete = ()=>resolve(res);\n        /* istanbul ignore next */ txn.onerror = ()=>reject(txn.error);\n    });\n}\nfunction $f19b912d87716459$var$closeDatabase(dbName) {\n    // close any open requests\n    const req = $f19b912d87716459$var$openIndexedDBRequests[dbName];\n    const db = req && req.result;\n    if (db) {\n        db.close();\n        const listeners = $f19b912d87716459$var$onCloseListeners[dbName];\n        /* istanbul ignore else */ if (listeners) for (const listener of listeners)listener();\n    }\n    delete $f19b912d87716459$var$openIndexedDBRequests[dbName];\n    delete $f19b912d87716459$var$databaseCache[dbName];\n    delete $f19b912d87716459$var$onCloseListeners[dbName];\n}\nfunction $f19b912d87716459$var$deleteDatabase(dbName) {\n    return new Promise((resolve, reject)=>{\n        // close any open requests\n        $f19b912d87716459$var$closeDatabase(dbName);\n        const req = indexedDB.deleteDatabase(dbName);\n        $f19b912d87716459$var$handleOpenOrDeleteReq(resolve, reject, req);\n    });\n}\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction $f19b912d87716459$var$addOnCloseListener(dbName, listener) {\n    let listeners = $f19b912d87716459$var$onCloseListeners[dbName];\n    if (!listeners) listeners = $f19b912d87716459$var$onCloseListeners[dbName] = [];\n    listeners.push(listener);\n}\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst $f19b912d87716459$var$irregularEmoticons = new Set([\n    \":D\",\n    \"XD\",\n    \":'D\",\n    \"O:)\",\n    \":X\",\n    \":P\",\n    \";P\",\n    \"XP\",\n    \":L\",\n    \":Z\",\n    \":j\",\n    \"8D\",\n    \"XO\",\n    \"8)\",\n    \":B\",\n    \":O\",\n    \":S\",\n    \":'o\",\n    \"Dx\",\n    \"X(\",\n    \"D:\",\n    \":C\",\n    \">0)\",\n    \":3\",\n    \"</3\",\n    \"<3\",\n    \"\\\\M/\",\n    \":E\",\n    \"8#\"\n]);\nfunction $f19b912d87716459$var$extractTokens(str) {\n    return str.split(/[\\s_]+/).map((word)=>{\n        if (!word.match(/\\w/) || $f19b912d87716459$var$irregularEmoticons.has(word)) // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase();\n        return word.replace(/[)(:,]/g, \"\").replace(//g, \"'\").toLowerCase();\n    }).filter(Boolean);\n}\nconst $f19b912d87716459$var$MIN_SEARCH_TEXT_LENGTH = 2;\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction $f19b912d87716459$var$normalizeTokens(str) {\n    return str.filter(Boolean).map((_)=>_.toLowerCase()).filter((_)=>_.length >= $f19b912d87716459$var$MIN_SEARCH_TEXT_LENGTH);\n}\n// Transform emoji data for storage in IDB\nfunction $f19b912d87716459$var$transformEmojiData(emojiData) {\n    const res = emojiData.map(({ annotation: annotation, emoticon: emoticon, group: group, order: order, shortcodes: shortcodes, skins: skins, tags: tags, emoji: emoji, version: version })=>{\n        const tokens = [\n            ...new Set($f19b912d87716459$var$normalizeTokens([\n                ...(shortcodes || []).map($f19b912d87716459$var$extractTokens).flat(),\n                ...tags.map($f19b912d87716459$var$extractTokens).flat(),\n                ...$f19b912d87716459$var$extractTokens(annotation),\n                emoticon\n            ]))\n        ].sort();\n        const res = {\n            annotation: annotation,\n            group: group,\n            order: order,\n            tags: tags,\n            tokens: tokens,\n            unicode: emoji,\n            version: version\n        };\n        if (emoticon) res.emoticon = emoticon;\n        if (shortcodes) res.shortcodes = shortcodes;\n        if (skins) {\n            res.skinTones = [];\n            res.skinUnicodes = [];\n            res.skinVersions = [];\n            for (const { tone: tone, emoji: emoji, version: version } of skins){\n                res.skinTones.push(tone);\n                res.skinUnicodes.push(emoji);\n                res.skinVersions.push(version);\n            }\n        }\n        return res;\n    });\n    return res;\n}\n// helper functions that help compress the code better\nfunction $f19b912d87716459$var$callStore(store, method, key, cb) {\n    store[method](key).onsuccess = (e)=>cb && cb(e.target.result);\n}\nfunction $f19b912d87716459$var$getIDB(store, key, cb) {\n    $f19b912d87716459$var$callStore(store, \"get\", key, cb);\n}\nfunction $f19b912d87716459$var$getAllIDB(store, key, cb) {\n    $f19b912d87716459$var$callStore(store, \"getAll\", key, cb);\n}\nfunction $f19b912d87716459$var$commit(txn) {\n    /* istanbul ignore else */ if (txn.commit) txn.commit();\n}\n// like lodash's minBy\nfunction $f19b912d87716459$var$minBy(array, func) {\n    let minItem = array[0];\n    for(let i = 1; i < array.length; i++){\n        const item = array[i];\n        if (func(minItem) > func(item)) minItem = item;\n    }\n    return minItem;\n}\n// return an array of results representing all items that are found in each one of the arrays\n//\nfunction $f19b912d87716459$var$findCommonMembers(arrays, uniqByFunc) {\n    const shortestArray = $f19b912d87716459$var$minBy(arrays, (_)=>_.length);\n    const results = [];\n    for (const item of shortestArray)// if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some((array)=>array.findIndex((_)=>uniqByFunc(_) === uniqByFunc(item)) === -1)) results.push(item);\n    return results;\n}\nasync function $f19b912d87716459$var$isEmpty(db) {\n    return !await $f19b912d87716459$var$get(db, $f19b912d87716459$var$STORE_KEYVALUE, $f19b912d87716459$var$KEY_URL);\n}\nasync function $f19b912d87716459$var$hasData(db, url, eTag) {\n    const [oldETag, oldUrl] = await Promise.all([\n        $f19b912d87716459$var$KEY_ETAG,\n        $f19b912d87716459$var$KEY_URL\n    ].map((key)=>$f19b912d87716459$var$get(db, $f19b912d87716459$var$STORE_KEYVALUE, key)));\n    return oldETag === eTag && oldUrl === url;\n}\nasync function $f19b912d87716459$var$doFullDatabaseScanForSingleResult(db, predicate) {\n    // This batching algorithm is just a perf improvement over a basic\n    // cursor. The BATCH_SIZE is an estimate of what would give the best\n    // perf for doing a full DB scan (worst case).\n    //\n    // Mini-benchmark for determining the best batch size:\n    //\n    // PERF=1 yarn build:rollup && yarn test:adhoc\n    //\n    // (async () => {\n    //   performance.mark('start')\n    //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n    //   performance.measure('total', 'start')\n    //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n    // })()\n    const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n    return $f19b912d87716459$var$dbPromise(db, $f19b912d87716459$var$STORE_EMOJI, $f19b912d87716459$var$MODE_READONLY, (emojiStore, txn, cb)=>{\n        let lastKey;\n        const processNextBatch = ()=>{\n            emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = (e)=>{\n                const results = e.target.result;\n                for (const result of results){\n                    lastKey = result.unicode;\n                    if (predicate(result)) return cb(result);\n                }\n                if (results.length < BATCH_SIZE) return cb();\n                processNextBatch();\n            };\n        };\n        processNextBatch();\n    });\n}\nasync function $f19b912d87716459$var$loadData(db, emojiData, url, eTag) {\n    {\n        const transformedData = $f19b912d87716459$var$transformEmojiData(emojiData);\n        await $f19b912d87716459$var$dbPromise(db, [\n            $f19b912d87716459$var$STORE_EMOJI,\n            $f19b912d87716459$var$STORE_KEYVALUE\n        ], $f19b912d87716459$var$MODE_READWRITE, ([emojiStore, metaStore], txn)=>{\n            let oldETag;\n            let oldUrl;\n            let todo = 0;\n            function checkFetched() {\n                if (++todo === 2) onFetched();\n            }\n            function onFetched() {\n                if (oldETag === eTag && oldUrl === url) // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n                return;\n                // delete old data\n                emojiStore.clear();\n                // insert new data\n                for (const data of transformedData)emojiStore.put(data);\n                metaStore.put(eTag, $f19b912d87716459$var$KEY_ETAG);\n                metaStore.put(url, $f19b912d87716459$var$KEY_URL);\n                $f19b912d87716459$var$commit(txn);\n            }\n            $f19b912d87716459$var$getIDB(metaStore, $f19b912d87716459$var$KEY_ETAG, (result)=>{\n                oldETag = result;\n                checkFetched();\n            });\n            $f19b912d87716459$var$getIDB(metaStore, $f19b912d87716459$var$KEY_URL, (result)=>{\n                oldUrl = result;\n                checkFetched();\n            });\n        });\n    }\n}\nasync function $f19b912d87716459$var$getEmojiByGroup(db, group) {\n    return $f19b912d87716459$var$dbPromise(db, $f19b912d87716459$var$STORE_EMOJI, $f19b912d87716459$var$MODE_READONLY, (emojiStore, txn, cb)=>{\n        const range = IDBKeyRange.bound([\n            group,\n            0\n        ], [\n            group + 1,\n            0\n        ], false, true);\n        $f19b912d87716459$var$getAllIDB(emojiStore.index($f19b912d87716459$var$INDEX_GROUP_AND_ORDER), range, cb);\n    });\n}\nasync function $f19b912d87716459$var$getEmojiBySearchQuery(db, query) {\n    const tokens = $f19b912d87716459$var$normalizeTokens($f19b912d87716459$var$extractTokens(query));\n    if (!tokens.length) return [];\n    return $f19b912d87716459$var$dbPromise(db, $f19b912d87716459$var$STORE_EMOJI, $f19b912d87716459$var$MODE_READONLY, (emojiStore, txn, cb)=>{\n        // get all results that contain all tokens (i.e. an AND query)\n        const intermediateResults = [];\n        const checkDone = ()=>{\n            if (intermediateResults.length === tokens.length) onDone();\n        };\n        const onDone = ()=>{\n            const results = $f19b912d87716459$var$findCommonMembers(intermediateResults, (_)=>_.unicode);\n            cb(results.sort((a, b)=>a.order < b.order ? -1 : 1));\n        };\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            const range = i === tokens.length - 1 ? IDBKeyRange.bound(token, token + \"\\uFFFF\", false, true) // treat last token as a prefix search\n             : IDBKeyRange.only(token); // treat all other tokens as an exact match\n            $f19b912d87716459$var$getAllIDB(emojiStore.index($f19b912d87716459$var$INDEX_TOKENS), range, (result)=>{\n                intermediateResults.push(result);\n                checkDone();\n            });\n        }\n    });\n}\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function $f19b912d87716459$var$getEmojiByShortcode(db, shortcode) {\n    const emojis = await $f19b912d87716459$var$getEmojiBySearchQuery(db, shortcode);\n    // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n    // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n    // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n    // index on shortcodes.\n    if (!emojis.length) {\n        const predicate = (_)=>(_.shortcodes || []).includes(shortcode.toLowerCase());\n        return await $f19b912d87716459$var$doFullDatabaseScanForSingleResult(db, predicate) || null;\n    }\n    return emojis.filter((_)=>{\n        const lowerShortcodes = (_.shortcodes || []).map((_)=>_.toLowerCase());\n        return lowerShortcodes.includes(shortcode.toLowerCase());\n    })[0] || null;\n}\nasync function $f19b912d87716459$var$getEmojiByUnicode(db, unicode) {\n    return $f19b912d87716459$var$dbPromise(db, $f19b912d87716459$var$STORE_EMOJI, $f19b912d87716459$var$MODE_READONLY, (emojiStore, txn, cb)=>$f19b912d87716459$var$getIDB(emojiStore, unicode, (result)=>{\n            if (result) return cb(result);\n            $f19b912d87716459$var$getIDB(emojiStore.index($f19b912d87716459$var$INDEX_SKIN_UNICODE), unicode, (result)=>cb(result || null));\n        }));\n}\nfunction $f19b912d87716459$var$get(db, storeName, key) {\n    return $f19b912d87716459$var$dbPromise(db, storeName, $f19b912d87716459$var$MODE_READONLY, (store, txn, cb)=>$f19b912d87716459$var$getIDB(store, key, cb));\n}\nfunction $f19b912d87716459$var$set(db, storeName, key, value) {\n    return $f19b912d87716459$var$dbPromise(db, storeName, $f19b912d87716459$var$MODE_READWRITE, (store, txn)=>{\n        store.put(value, key);\n        $f19b912d87716459$var$commit(txn);\n    });\n}\nfunction $f19b912d87716459$var$incrementFavoriteEmojiCount(db, unicode) {\n    return $f19b912d87716459$var$dbPromise(db, $f19b912d87716459$var$STORE_FAVORITES, $f19b912d87716459$var$MODE_READWRITE, (store, txn)=>$f19b912d87716459$var$getIDB(store, unicode, (result)=>{\n            store.put((result || 0) + 1, unicode);\n            $f19b912d87716459$var$commit(txn);\n        }));\n}\nfunction $f19b912d87716459$var$getTopFavoriteEmoji(db, customEmojiIndex, limit) {\n    if (limit === 0) return [];\n    return $f19b912d87716459$var$dbPromise(db, [\n        $f19b912d87716459$var$STORE_FAVORITES,\n        $f19b912d87716459$var$STORE_EMOJI\n    ], $f19b912d87716459$var$MODE_READONLY, ([favoritesStore, emojiStore], txn, cb)=>{\n        const results = [];\n        favoritesStore.index($f19b912d87716459$var$INDEX_COUNT).openCursor(undefined, \"prev\").onsuccess = (e)=>{\n            const cursor = e.target.result;\n            if (!cursor) return cb(results);\n            function addResult(result) {\n                results.push(result);\n                if (results.length === limit) return cb(results) // done, reached the limit\n                ;\n                cursor.continue();\n            }\n            const unicodeOrName = cursor.primaryKey;\n            const custom = customEmojiIndex.byName(unicodeOrName);\n            if (custom) return addResult(custom);\n            // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n            // but my testing suggests it's not actually faster.\n            $f19b912d87716459$var$getIDB(emojiStore, unicodeOrName, (emoji)=>{\n                if (emoji) return addResult(emoji);\n                // emoji not found somehow, ignore (may happen if custom emoji change)\n                cursor.continue();\n            });\n        };\n    });\n}\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\nconst $f19b912d87716459$var$CODA_MARKER = \"\"; // marks the end of the string\nfunction $f19b912d87716459$var$trie(arr, itemToTokens) {\n    const map = new Map();\n    for (const item of arr){\n        const tokens = itemToTokens(item);\n        for (const token of tokens){\n            let currentMap = map;\n            for(let i = 0; i < token.length; i++){\n                const char = token.charAt(i);\n                let nextMap = currentMap.get(char);\n                if (!nextMap) {\n                    nextMap = new Map();\n                    currentMap.set(char, nextMap);\n                }\n                currentMap = nextMap;\n            }\n            let valuesAtCoda = currentMap.get($f19b912d87716459$var$CODA_MARKER);\n            if (!valuesAtCoda) {\n                valuesAtCoda = [];\n                currentMap.set($f19b912d87716459$var$CODA_MARKER, valuesAtCoda);\n            }\n            valuesAtCoda.push(item);\n        }\n    }\n    const search = (query, exact)=>{\n        let currentMap = map;\n        for(let i = 0; i < query.length; i++){\n            const char = query.charAt(i);\n            const nextMap = currentMap.get(char);\n            if (nextMap) currentMap = nextMap;\n            else return [];\n        }\n        if (exact) {\n            const results = currentMap.get($f19b912d87716459$var$CODA_MARKER);\n            return results || [];\n        }\n        const results = [];\n        // traverse\n        const queue = [\n            currentMap\n        ];\n        while(queue.length){\n            const currentMap = queue.shift();\n            const entriesSortedByKey = [\n                ...currentMap.entries()\n            ].sort((a, b)=>a[0] < b[0] ? -1 : 1);\n            for (const [key, value] of entriesSortedByKey)if (key === $f19b912d87716459$var$CODA_MARKER) results.push(...value);\n            else queue.push(value);\n        }\n        return results;\n    };\n    return search;\n}\nconst $f19b912d87716459$var$requiredKeys$1 = [\n    \"name\",\n    \"url\"\n];\nfunction $f19b912d87716459$var$assertCustomEmojis(customEmojis) {\n    const isArray = customEmojis && Array.isArray(customEmojis);\n    const firstItemIsFaulty = isArray && customEmojis.length && (!customEmojis[0] || $f19b912d87716459$var$requiredKeys$1.some((key)=>!(key in customEmojis[0])));\n    if (!isArray || firstItemIsFaulty) throw new Error(\"Custom emojis are in the wrong format\");\n}\nfunction $f19b912d87716459$var$customEmojiIndex(customEmojis) {\n    $f19b912d87716459$var$assertCustomEmojis(customEmojis);\n    const sortByName = (a, b)=>a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n    //\n    // all()\n    //\n    const all = customEmojis.sort(sortByName);\n    //\n    // search()\n    //\n    const emojiToTokens = (emoji)=>[\n            ...new Set((emoji.shortcodes || []).map((shortcode)=>$f19b912d87716459$var$extractTokens(shortcode)).flat())\n        ];\n    const searchTrie = $f19b912d87716459$var$trie(customEmojis, emojiToTokens);\n    const searchByExactMatch = (_)=>searchTrie(_, true);\n    const searchByPrefix = (_)=>searchTrie(_, false);\n    // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n    // is treated as a prefix search, but every other one is treated as an exact match.\n    // Then we AND the results together\n    const search = (query)=>{\n        const tokens = $f19b912d87716459$var$extractTokens(query);\n        const intermediateResults = tokens.map((token, i)=>(i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token));\n        return $f19b912d87716459$var$findCommonMembers(intermediateResults, (_)=>_.name).sort(sortByName);\n    };\n    //\n    // byShortcode, byName\n    //\n    const shortcodeToEmoji = new Map();\n    const nameToEmoji = new Map();\n    for (const customEmoji of customEmojis){\n        nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n        for (const shortcode of customEmoji.shortcodes || [])shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n    const byShortcode = (shortcode)=>shortcodeToEmoji.get(shortcode.toLowerCase());\n    const byName = (name)=>nameToEmoji.get(name.toLowerCase());\n    return {\n        all: all,\n        search: search,\n        byShortcode: byShortcode,\n        byName: byName\n    };\n}\nconst $f19b912d87716459$var$isFirefoxContentScript = typeof wrappedJSObject !== \"undefined\";\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction $f19b912d87716459$var$cleanEmoji(emoji) {\n    if (!emoji) return emoji;\n    // if inside a Firefox content script, need to clone the emoji object to prevent Firefox from complaining about\n    // cross-origin object. See: https://github.com/nolanlawson/emoji-picker-element/issues/356\n    /* istanbul ignore if */ if ($f19b912d87716459$var$isFirefoxContentScript) emoji = structuredClone(emoji);\n    delete emoji.tokens;\n    if (emoji.skinTones) {\n        const len = emoji.skinTones.length;\n        emoji.skins = Array(len);\n        for(let i = 0; i < len; i++)emoji.skins[i] = {\n            tone: emoji.skinTones[i],\n            unicode: emoji.skinUnicodes[i],\n            version: emoji.skinVersions[i]\n        };\n        delete emoji.skinTones;\n        delete emoji.skinUnicodes;\n        delete emoji.skinVersions;\n    }\n    return emoji;\n}\nfunction $f19b912d87716459$var$warnETag(eTag) {\n    if (!eTag) console.warn(\"emoji-picker-element is more efficient if the dataSource server exposes an ETag header.\");\n}\nconst $f19b912d87716459$var$requiredKeys = [\n    \"annotation\",\n    \"emoji\",\n    \"group\",\n    \"order\",\n    \"tags\",\n    \"version\"\n];\nfunction $f19b912d87716459$var$assertEmojiData(emojiData) {\n    if (!emojiData || !Array.isArray(emojiData) || !emojiData[0] || typeof emojiData[0] !== \"object\" || $f19b912d87716459$var$requiredKeys.some((key)=>!(key in emojiData[0]))) throw new Error(\"Emoji data is in the wrong format\");\n}\nfunction $f19b912d87716459$var$assertStatus(response, dataSource) {\n    if (Math.floor(response.status / 100) !== 2) throw new Error(\"Failed to fetch: \" + dataSource + \":  \" + response.status);\n}\nasync function $f19b912d87716459$var$getETag(dataSource) {\n    const response = await fetch(dataSource, {\n        method: \"HEAD\"\n    });\n    $f19b912d87716459$var$assertStatus(response, dataSource);\n    const eTag = response.headers.get(\"etag\");\n    $f19b912d87716459$var$warnETag(eTag);\n    return eTag;\n}\nasync function $f19b912d87716459$var$getETagAndData(dataSource) {\n    const response = await fetch(dataSource);\n    $f19b912d87716459$var$assertStatus(response, dataSource);\n    const eTag = response.headers.get(\"etag\");\n    $f19b912d87716459$var$warnETag(eTag);\n    const emojiData = await response.json();\n    $f19b912d87716459$var$assertEmojiData(emojiData);\n    return [\n        eTag,\n        emojiData\n    ];\n}\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n// even with --excludePrivate \\_()_/\n/** @private */ /**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */ function $f19b912d87716459$var$arrayBufferToBinaryString(buffer) {\n    var binary = \"\";\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while(++i < length)binary += String.fromCharCode(bytes[i]);\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */ function $f19b912d87716459$var$binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while(++i < length)arr[i] = binary.charCodeAt(i);\n    return buf;\n}\n// generate a checksum based on the stringified JSON\nasync function $f19b912d87716459$var$jsonChecksum(object) {\n    const inString = JSON.stringify(object);\n    let inBuffer = $f19b912d87716459$var$binaryStringToArrayBuffer(inString);\n    // this does not need to be cryptographically secure, SHA-1 is fine\n    const outBuffer = await crypto.subtle.digest(\"SHA-1\", inBuffer);\n    const outBinString = $f19b912d87716459$var$arrayBufferToBinaryString(outBuffer);\n    const res = btoa(outBinString);\n    return res;\n}\nasync function $f19b912d87716459$var$checkForUpdates(db, dataSource) {\n    // just do a simple HEAD request first to see if the eTags match\n    let emojiData;\n    let eTag = await $f19b912d87716459$var$getETag(dataSource);\n    if (!eTag) {\n        const eTagAndData = await $f19b912d87716459$var$getETagAndData(dataSource);\n        eTag = eTagAndData[0];\n        emojiData = eTagAndData[1];\n        if (!eTag) eTag = await $f19b912d87716459$var$jsonChecksum(emojiData);\n    }\n    if (await $f19b912d87716459$var$hasData(db, dataSource, eTag)) ;\n    else {\n        if (!emojiData) {\n            const eTagAndData = await $f19b912d87716459$var$getETagAndData(dataSource);\n            emojiData = eTagAndData[1];\n        }\n        await $f19b912d87716459$var$loadData(db, emojiData, dataSource, eTag);\n    }\n}\nasync function $f19b912d87716459$var$loadDataForFirstTime(db, dataSource) {\n    let [eTag, emojiData] = await $f19b912d87716459$var$getETagAndData(dataSource);\n    if (!eTag) // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await $f19b912d87716459$var$jsonChecksum(emojiData);\n    await $f19b912d87716459$var$loadData(db, emojiData, dataSource, eTag);\n}\nclass $f19b912d87716459$export$2e2bcd8739ae039 {\n    constructor({ dataSource: dataSource = $f19b912d87716459$var$DEFAULT_DATA_SOURCE, locale: locale = $f19b912d87716459$var$DEFAULT_LOCALE, customEmoji: customEmoji = [] } = {}){\n        this.dataSource = dataSource;\n        this.locale = locale;\n        this._dbName = `emoji-picker-element-${this.locale}`;\n        this._db = undefined;\n        this._lazyUpdate = undefined;\n        this._custom = $f19b912d87716459$var$customEmojiIndex(customEmoji);\n        this._clear = this._clear.bind(this);\n        this._ready = this._init();\n    }\n    async _init() {\n        const db = this._db = await $f19b912d87716459$var$openDatabase(this._dbName);\n        $f19b912d87716459$var$addOnCloseListener(this._dbName, this._clear);\n        const dataSource = this.dataSource;\n        const empty = await $f19b912d87716459$var$isEmpty(db);\n        if (empty) await $f19b912d87716459$var$loadDataForFirstTime(db, dataSource);\n        else this._lazyUpdate = $f19b912d87716459$var$checkForUpdates(db, dataSource);\n    }\n    async ready() {\n        const checkReady = async ()=>{\n            if (!this._ready) this._ready = this._init();\n            return this._ready;\n        };\n        await checkReady();\n        // There's a possibility of a race condition where the element gets added, removed, and then added again\n        // with a particular timing, which would set the _db to undefined.\n        // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n        if (!this._db) await checkReady();\n    }\n    async getEmojiByGroup(group) {\n        $f19b912d87716459$var$assertNumber(group);\n        await this.ready();\n        return $f19b912d87716459$var$uniqEmoji(await $f19b912d87716459$var$getEmojiByGroup(this._db, group)).map($f19b912d87716459$var$cleanEmoji);\n    }\n    async getEmojiBySearchQuery(query) {\n        $f19b912d87716459$var$assertNonEmptyString(query);\n        await this.ready();\n        const customs = this._custom.search(query);\n        const natives = $f19b912d87716459$var$uniqEmoji(await $f19b912d87716459$var$getEmojiBySearchQuery(this._db, query)).map($f19b912d87716459$var$cleanEmoji);\n        return [\n            ...customs,\n            ...natives\n        ];\n    }\n    async getEmojiByShortcode(shortcode) {\n        $f19b912d87716459$var$assertNonEmptyString(shortcode);\n        await this.ready();\n        const custom = this._custom.byShortcode(shortcode);\n        if (custom) return custom;\n        return $f19b912d87716459$var$cleanEmoji(await $f19b912d87716459$var$getEmojiByShortcode(this._db, shortcode));\n    }\n    async getEmojiByUnicodeOrName(unicodeOrName) {\n        $f19b912d87716459$var$assertNonEmptyString(unicodeOrName);\n        await this.ready();\n        const custom = this._custom.byName(unicodeOrName);\n        if (custom) return custom;\n        return $f19b912d87716459$var$cleanEmoji(await $f19b912d87716459$var$getEmojiByUnicode(this._db, unicodeOrName));\n    }\n    async getPreferredSkinTone() {\n        await this.ready();\n        return await $f19b912d87716459$var$get(this._db, $f19b912d87716459$var$STORE_KEYVALUE, $f19b912d87716459$var$KEY_PREFERRED_SKINTONE) || 0;\n    }\n    async setPreferredSkinTone(skinTone) {\n        $f19b912d87716459$var$assertNumber(skinTone);\n        await this.ready();\n        return $f19b912d87716459$var$set(this._db, $f19b912d87716459$var$STORE_KEYVALUE, $f19b912d87716459$var$KEY_PREFERRED_SKINTONE, skinTone);\n    }\n    async incrementFavoriteEmojiCount(unicodeOrName) {\n        $f19b912d87716459$var$assertNonEmptyString(unicodeOrName);\n        await this.ready();\n        return $f19b912d87716459$var$incrementFavoriteEmojiCount(this._db, unicodeOrName);\n    }\n    async getTopFavoriteEmoji(limit) {\n        $f19b912d87716459$var$assertNumber(limit);\n        await this.ready();\n        return (await $f19b912d87716459$var$getTopFavoriteEmoji(this._db, this._custom, limit)).map($f19b912d87716459$var$cleanEmoji);\n    }\n    set customEmoji(customEmojis) {\n        this._custom = $f19b912d87716459$var$customEmojiIndex(customEmojis);\n    }\n    get customEmoji() {\n        return this._custom.all;\n    }\n    async _shutdown() {\n        await this.ready(); // reopen if we've already been closed/deleted\n        try {\n            await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n        } catch (err) {}\n    }\n    // clear references to IDB, e.g. during a close event\n    _clear() {\n        // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n        // The memory leak tests prove this is unnecessary. It's because:\n        // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n        // 2) we clear the manual close listeners in databaseLifecycle.js.\n        this._db = this._ready = this._lazyUpdate = undefined;\n    }\n    async close() {\n        await this._shutdown();\n        await $f19b912d87716459$var$closeDatabase(this._dbName);\n    }\n    async delete() {\n        await this._shutdown();\n        await $f19b912d87716459$var$deleteDatabase(this._dbName);\n    }\n}\n\n\n// via https://unpkg.com/browse/emojibase-data@6.0.0/meta/groups.json\nconst $be550d328187eb94$var$allGroups = [\n    [\n        -1,\n        \"\\u2728\",\n        \"custom\"\n    ],\n    [\n        0,\n        \"\\uD83D\\uDE00\",\n        \"smileys-emotion\"\n    ],\n    [\n        1,\n        \"\\uD83D\\uDC4B\",\n        \"people-body\"\n    ],\n    [\n        3,\n        \"\\uD83D\\uDC31\",\n        \"animals-nature\"\n    ],\n    [\n        4,\n        \"\\uD83C\\uDF4E\",\n        \"food-drink\"\n    ],\n    [\n        5,\n        \"\\uD83C\\uDFE0\\uFE0F\",\n        \"travel-places\"\n    ],\n    [\n        6,\n        \"\\u26BD\",\n        \"activities\"\n    ],\n    [\n        7,\n        \"\\uD83D\\uDCDD\",\n        \"objects\"\n    ],\n    [\n        8,\n        \"\\u26D4\\uFE0F\",\n        \"symbols\"\n    ],\n    [\n        9,\n        \"\\uD83C\\uDFC1\",\n        \"flags\"\n    ]\n].map(([id, emoji, name])=>({\n        id: id,\n        emoji: emoji,\n        name: name\n    }));\nconst $be550d328187eb94$var$groups = $be550d328187eb94$var$allGroups.slice(1);\nconst $be550d328187eb94$var$MIN_SEARCH_TEXT_LENGTH = 2;\nconst $be550d328187eb94$var$NUM_SKIN_TONES = 6;\n/* istanbul ignore next */ const $be550d328187eb94$var$rIC = typeof requestIdleCallback === \"function\" ? requestIdleCallback : setTimeout;\n// check for ZWJ (zero width joiner) character\nfunction $be550d328187eb94$var$hasZwj(emoji) {\n    return emoji.unicode.includes(\"\\u200D\");\n}\n// Find one good representative emoji from each version to test by checking its color.\n// Ideally it should have color in the center. For some inspiration, see:\n// https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n//\n// Note that for certain versions (12.1, 13.1), there is no point in testing them explicitly, because\n// all the emoji from this version are compound-emoji from previous versions. So they would pass a color\n// test, even in browsers that display them as double emoji. (E.g. \"face in clouds\" might render as\n// \"face without mouth\" plus \"fog\".) These emoji can only be filtered using the width test,\n// which happens in checkZwjSupport.js.\nconst $be550d328187eb94$var$versionsAndTestEmoji = {\n    \"\\uD83E\\uDEE8\": 15.1,\n    \"\\uD83E\\uDEE0\": 14,\n    \"\\uD83E\\uDD72\": 13.1,\n    \"\\uD83E\\uDD7B\": 12.1,\n    \"\\uD83E\\uDD70\": 11,\n    \"\\uD83E\\uDD29\": 5,\n    \"\\uD83D\\uDC71\\u200D\\u2640\\uFE0F\": 4,\n    \"\\uD83E\\uDD23\": 3,\n    \"\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8\\uFE0F\": 2,\n    \"\\uD83D\\uDE00\": 1,\n    \"\\uD83D\\uDE10\\uFE0F\": 0.7,\n    \"\\uD83D\\uDE03\": 0.6\n};\nconst $be550d328187eb94$var$TIMEOUT_BEFORE_LOADING_MESSAGE = 1000; // 1 second\nconst $be550d328187eb94$var$DEFAULT_SKIN_TONE_EMOJI = \"\\uD83D\\uDD90\\uFE0F\";\nconst $be550d328187eb94$var$DEFAULT_NUM_COLUMNS = 8;\n// Based on https://fivethirtyeight.com/features/the-100-most-used-emojis/ and\n// https://blog.emojipedia.org/facebook-reveals-most-and-least-used-emojis/ with\n// a bit of my own curation. (E.g. avoid the \"OK\" gesture because of connotations:\n// https://emojipedia.org/ok-hand/)\nconst $be550d328187eb94$var$MOST_COMMONLY_USED_EMOJI = [\n    \"\\uD83D\\uDE0A\",\n    \"\\uD83D\\uDE12\",\n    \"\\u2764\\uFE0F\",\n    \"\\uD83D\\uDC4D\\uFE0F\",\n    \"\\uD83D\\uDE0D\",\n    \"\\uD83D\\uDE02\",\n    \"\\uD83D\\uDE2D\",\n    \"\\u263A\\uFE0F\",\n    \"\\uD83D\\uDE14\",\n    \"\\uD83D\\uDE29\",\n    \"\\uD83D\\uDE0F\",\n    \"\\uD83D\\uDC95\",\n    \"\\uD83D\\uDE4C\",\n    \"\\uD83D\\uDE18\"\n];\n// It's important to list Twemoji Mozilla before everything else, because Mozilla bundles their\n// own font on some platforms (notably Windows and Linux as of this writing). Typically, Mozilla\n// updates faster than the underlying OS, and we don't want to render older emoji in one font and\n// newer emoji in another font:\n// https://github.com/nolanlawson/emoji-picker-element/pull/268#issuecomment-1073347283\nconst $be550d328187eb94$var$FONT_FAMILY = '\"Twemoji Mozilla\",\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\",\"EmojiOne Color\",\"Android Emoji\",sans-serif';\n/* istanbul ignore next */ const $be550d328187eb94$var$DEFAULT_CATEGORY_SORTING = (a, b)=>a < b ? -1 : a > b ? 1 : 0;\n// Test if an emoji is supported by rendering it to canvas and checking that the color is not black\n// See https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n// and https://www.npmjs.com/package/if-emoji for inspiration\n// This implementation is largely borrowed from if-emoji, adding the font-family\nconst $be550d328187eb94$var$getTextFeature = (text, color)=>{\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.textBaseline = \"top\";\n    ctx.font = `100px ${$be550d328187eb94$var$FONT_FAMILY}`;\n    ctx.fillStyle = color;\n    ctx.scale(0.01, 0.01);\n    ctx.fillText(text, 0, 0);\n    return ctx.getImageData(0, 0, 1, 1).data;\n};\nconst $be550d328187eb94$var$compareFeatures = (feature1, feature2)=>{\n    const feature1Str = [\n        ...feature1\n    ].join(\",\");\n    const feature2Str = [\n        ...feature2\n    ].join(\",\");\n    // This is RGBA, so for 0,0,0, we are checking that the first RGB is not all zeroes.\n    // Most of the time when unsupported this is 0,0,0,0, but on Chrome on Mac it is\n    // 0,0,0,61 - there is a transparency here.\n    return feature1Str === feature2Str && !feature1Str.startsWith(\"0,0,0,\");\n};\nfunction $be550d328187eb94$var$testColorEmojiSupported(text) {\n    // Render white and black and then compare them to each other and ensure they're the same\n    // color, and neither one is black. This shows that the emoji was rendered in color.\n    const feature1 = $be550d328187eb94$var$getTextFeature(text, \"#000\");\n    const feature2 = $be550d328187eb94$var$getTextFeature(text, \"#fff\");\n    return feature1 && feature2 && $be550d328187eb94$var$compareFeatures(feature1, feature2);\n}\n// rather than check every emoji ever, which would be expensive, just check some representatives from the\n// different emoji releases to determine what the font supports\nfunction $be550d328187eb94$var$determineEmojiSupportLevel() {\n    const entries = Object.entries($be550d328187eb94$var$versionsAndTestEmoji);\n    try {\n        // start with latest emoji and work backwards\n        for (const [emoji, version] of entries){\n            if ($be550d328187eb94$var$testColorEmojiSupported(emoji)) return version;\n        }\n    } catch (e) {} finally{}\n    // In case of an error, be generous and just assume all emoji are supported (e.g. for canvas errors\n    // due to anti-fingerprinting add-ons). Better to show some gray boxes than nothing at all.\n    return entries[0][1] // first one in the list is the most recent version\n    ;\n}\n// Check which emojis we know for sure aren't supported, based on Unicode version level\nlet $be550d328187eb94$var$promise;\nconst $be550d328187eb94$var$detectEmojiSupportLevel = ()=>{\n    if (!$be550d328187eb94$var$promise) // Delay so it can run while the IDB database is being created by the browser (on another thread).\n    // This helps especially with first load  we want to start pre-populating the database on the main thread,\n    // and then wait for IDB to commit everything, and while waiting we run this check.\n    $be550d328187eb94$var$promise = new Promise((resolve)=>$be550d328187eb94$var$rIC(()=>resolve($be550d328187eb94$var$determineEmojiSupportLevel()) // delay so ideally this can run while IDB is first populating\n        ));\n    return $be550d328187eb94$var$promise;\n};\n// determine which emojis containing ZWJ (zero width joiner) characters\n// are supported (rendered as one glyph) rather than unsupported (rendered as two or more glyphs)\nconst $be550d328187eb94$var$supportedZwjEmojis = new Map();\nconst $be550d328187eb94$var$VARIATION_SELECTOR = \"\\uFE0F\";\nconst $be550d328187eb94$var$SKINTONE_MODIFIER = \"\\ud83c\";\nconst $be550d328187eb94$var$ZWJ = \"\\u200D\";\nconst $be550d328187eb94$var$LIGHT_SKIN_TONE = 0x1F3FB;\nconst $be550d328187eb94$var$LIGHT_SKIN_TONE_MODIFIER = 0xdffb;\n// TODO: this is a naive implementation, we can improve it later\n// It's only used for the skintone picker, so as long as people don't customize with\n// really exotic emoji then it should work fine\nfunction $be550d328187eb94$var$applySkinTone(str, skinTone) {\n    if (skinTone === 0) return str;\n    const zwjIndex = str.indexOf($be550d328187eb94$var$ZWJ);\n    if (zwjIndex !== -1) return str.substring(0, zwjIndex) + String.fromCodePoint($be550d328187eb94$var$LIGHT_SKIN_TONE + skinTone - 1) + str.substring(zwjIndex);\n    if (str.endsWith($be550d328187eb94$var$VARIATION_SELECTOR)) str = str.substring(0, str.length - 1);\n    return str + $be550d328187eb94$var$SKINTONE_MODIFIER + String.fromCodePoint($be550d328187eb94$var$LIGHT_SKIN_TONE_MODIFIER + skinTone - 1);\n}\nfunction $be550d328187eb94$var$halt(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\n// Implementation left/right or up/down navigation, circling back when you\n// reach the start/end of the list\nfunction $be550d328187eb94$var$incrementOrDecrement(decrement, val, arr) {\n    val += decrement ? -1 : 1;\n    if (val < 0) val = arr.length - 1;\n    else if (val >= arr.length) val = 0;\n    return val;\n}\n// like lodash's uniqBy but much smaller\nfunction $be550d328187eb94$var$uniqBy(arr, func) {\n    const set = new Set();\n    const res = [];\n    for (const item of arr){\n        const key = func(item);\n        if (!set.has(key)) {\n            set.add(key);\n            res.push(item);\n        }\n    }\n    return res;\n}\n// We don't need all the data on every emoji, and there are specific things we need\n// for the UI, so build a \"view model\" from the emoji object we got from the database\nfunction $be550d328187eb94$var$summarizeEmojisForUI(emojis, emojiSupportLevel) {\n    const toSimpleSkinsMap = (skins)=>{\n        const res = {};\n        for (const skin of skins)// ignore arrays like [1, 2] with multiple skin tones\n        // also ignore variants that are in an unsupported emoji version\n        // (these do exist - variants from a different version than their base emoji)\n        if (typeof skin.tone === \"number\" && skin.version <= emojiSupportLevel) res[skin.tone] = skin.unicode;\n        return res;\n    };\n    return emojis.map(({ unicode: unicode, skins: skins, shortcodes: shortcodes, url: url, name: name, category: category, annotation: annotation })=>({\n            unicode: unicode,\n            name: name,\n            shortcodes: shortcodes,\n            url: url,\n            category: category,\n            annotation: annotation,\n            id: unicode || name,\n            skins: skins && toSimpleSkinsMap(skins)\n        }));\n}\n// import rAF from one place so that the bundle size is a bit smaller\nconst $be550d328187eb94$var$rAF = requestAnimationFrame;\n// Svelte action to calculate the width of an element and auto-update\n// using ResizeObserver. If ResizeObserver is unsupported, we just use rAF once\n// and don't bother to update.\nlet $be550d328187eb94$var$resizeObserverSupported = typeof ResizeObserver === \"function\";\nfunction $be550d328187eb94$var$calculateWidth(node, abortSignal, onUpdate) {\n    let resizeObserver;\n    if ($be550d328187eb94$var$resizeObserverSupported) {\n        resizeObserver = new ResizeObserver((entries)=>onUpdate(entries[0].contentRect.width));\n        resizeObserver.observe(node);\n    } else $be550d328187eb94$var$rAF(()=>onUpdate(node.getBoundingClientRect().width));\n    // cleanup function (called on destroy)\n    abortSignal.addEventListener(\"abort\", ()=>{\n        if (resizeObserver) resizeObserver.disconnect();\n    });\n}\n// get the width of the text inside of a DOM node, via https://stackoverflow.com/a/59525891/680742\nfunction $be550d328187eb94$var$calculateTextWidth(node) {\n    /* istanbul ignore else */ {\n        const range = document.createRange();\n        range.selectNode(node.firstChild);\n        return range.getBoundingClientRect().width;\n    }\n}\nlet $be550d328187eb94$var$baselineEmojiWidth;\nfunction $be550d328187eb94$var$checkZwjSupport(zwjEmojisToCheck, baselineEmoji, emojiToDomNode) {\n    for (const emoji of zwjEmojisToCheck){\n        const domNode = emojiToDomNode(emoji);\n        const emojiWidth = $be550d328187eb94$var$calculateTextWidth(domNode);\n        if (typeof $be550d328187eb94$var$baselineEmojiWidth === \"undefined\") $be550d328187eb94$var$baselineEmojiWidth = $be550d328187eb94$var$calculateTextWidth(baselineEmoji);\n        // On Windows, some supported emoji are ~50% bigger than the baseline emoji, but what we really want to guard\n        // against are the ones that are 2x the size, because those are truly broken (person with red hair = person with\n        // floating red wig, black cat = cat with black square, polar bear = bear with snowflake, etc.)\n        // So here we set the threshold at 1.8 times the size of the baseline emoji.\n        const supported = emojiWidth / 1.8 < $be550d328187eb94$var$baselineEmojiWidth;\n        $be550d328187eb94$var$supportedZwjEmojis.set(emoji.unicode, supported);\n    }\n}\n// like lodash's uniq\nfunction $be550d328187eb94$var$uniq(arr) {\n    return $be550d328187eb94$var$uniqBy(arr, (_)=>_);\n}\n// Note we put this in its own function outside Picker.js to avoid Svelte doing an invalidation on the \"setter\" here.\n// At best the invalidation is useless, at worst it can cause infinite loops:\n// https://github.com/nolanlawson/emoji-picker-element/pull/180\n// https://github.com/sveltejs/svelte/issues/6521\n// Also note tabpanelElement can be null if the element is disconnected immediately after connected\nfunction $be550d328187eb94$var$resetScrollTopIfPossible(element) {\n    /* istanbul ignore else */ if (element) element.scrollTop = 0;\n}\nfunction $be550d328187eb94$var$getFromMap(cache, key, func) {\n    let cached = cache.get(key);\n    if (!cached) {\n        cached = func();\n        cache.set(key, cached);\n    }\n    return cached;\n}\nfunction $be550d328187eb94$var$toString(value) {\n    return \"\" + value;\n}\nfunction $be550d328187eb94$var$parseTemplate(htmlString) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = htmlString;\n    return template;\n}\nconst $be550d328187eb94$var$parseCache = new WeakMap();\nconst $be550d328187eb94$var$domInstancesCache = new WeakMap();\n// This needs to be a symbol because it needs to be different from any possible output of a key function\nconst $be550d328187eb94$var$unkeyedSymbol = Symbol(\"un-keyed\");\n// Not supported in Safari <=13\nconst $be550d328187eb94$var$hasReplaceChildren = \"replaceChildren\" in Element.prototype;\nfunction $be550d328187eb94$var$replaceChildren(parentNode, newChildren) {\n    /* istanbul ignore else */ if ($be550d328187eb94$var$hasReplaceChildren) parentNode.replaceChildren(...newChildren);\n    else {\n        parentNode.innerHTML = \"\";\n        parentNode.append(...newChildren);\n    }\n}\nfunction $be550d328187eb94$var$doChildrenNeedRerender(parentNode, newChildren) {\n    let oldChild = parentNode.firstChild;\n    let oldChildrenCount = 0;\n    // iterate using firstChild/nextSibling because browsers use a linked list under the hood\n    while(oldChild){\n        const newChild = newChildren[oldChildrenCount];\n        // check if the old child and new child are the same\n        if (newChild !== oldChild) return true;\n        oldChild = oldChild.nextSibling;\n        oldChildrenCount++;\n    }\n    // if new children length is different from old, we must re-render\n    return oldChildrenCount !== newChildren.length;\n}\nfunction $be550d328187eb94$var$patchChildren(newChildren, instanceBinding) {\n    const { targetNode: targetNode } = instanceBinding;\n    let { targetParentNode: targetParentNode } = instanceBinding;\n    let needsRerender = false;\n    if (targetParentNode) needsRerender = $be550d328187eb94$var$doChildrenNeedRerender(targetParentNode, newChildren);\n    else {\n        needsRerender = true;\n        instanceBinding.targetNode = undefined; // placeholder node not needed anymore, free memory\n        instanceBinding.targetParentNode = targetParentNode = targetNode.parentNode;\n    }\n    // avoid re-rendering list if the dom nodes are exactly the same before and after\n    if (needsRerender) $be550d328187eb94$var$replaceChildren(targetParentNode, newChildren);\n}\nfunction $be550d328187eb94$var$patch(expressions, instanceBindings) {\n    for (const instanceBinding of instanceBindings){\n        const { targetNode: targetNode, currentExpression: currentExpression, binding: { expressionIndex: expressionIndex, attributeName: attributeName, attributeValuePre: attributeValuePre, attributeValuePost: attributeValuePost } } = instanceBinding;\n        const expression = expressions[expressionIndex];\n        if (currentExpression === expression) continue;\n        instanceBinding.currentExpression = expression;\n        if (attributeName) targetNode.setAttribute(attributeName, attributeValuePre + $be550d328187eb94$var$toString(expression) + attributeValuePost);\n        else {\n            let newNode;\n            if (Array.isArray(expression)) $be550d328187eb94$var$patchChildren(expression, instanceBinding);\n            else if (expression instanceof Element) {\n                newNode = expression;\n                targetNode.replaceWith(newNode);\n            } else // nodeValue is faster than textContent supposedly https://www.youtube.com/watch?v=LY6y3HbDVmg\n            // note we may be replacing the value in a placeholder text node\n            targetNode.nodeValue = $be550d328187eb94$var$toString(expression);\n            if (newNode) instanceBinding.targetNode = newNode;\n        }\n    }\n}\nfunction $be550d328187eb94$var$parse(tokens) {\n    let htmlString = \"\";\n    let withinTag = false;\n    let withinAttribute = false;\n    let elementIndexCounter = -1; // depth-first traversal order\n    const elementsToBindings = new Map();\n    const elementIndexes = [];\n    for(let i = 0, len = tokens.length; i < len; i++){\n        const token = tokens[i];\n        htmlString += token;\n        if (i === len - 1) break; // no need to process characters - no more expressions to be found\n        for(let j = 0; j < token.length; j++){\n            const char = token.charAt(j);\n            switch(char){\n                case \"<\":\n                    {\n                        const nextChar = token.charAt(j + 1);\n                        if (nextChar === \"/\") // leaving an element\n                        elementIndexes.pop();\n                        else {\n                            withinTag = true;\n                            elementIndexes.push(++elementIndexCounter);\n                        }\n                        break;\n                    }\n                case \">\":\n                    withinTag = false;\n                    withinAttribute = false;\n                    break;\n                case \"=\":\n                    withinAttribute = true;\n                    break;\n            }\n        }\n        const elementIndex = elementIndexes[elementIndexes.length - 1];\n        const bindings = $be550d328187eb94$var$getFromMap(elementsToBindings, elementIndex, ()=>[]);\n        let attributeName;\n        let attributeValuePre;\n        let attributeValuePost;\n        if (withinAttribute) {\n            // I never use single-quotes for attribute values in HTML, so just support double-quotes or no-quotes\n            const match = /(\\S+)=\"?([^\"=]*)$/.exec(token);\n            attributeName = match[1];\n            attributeValuePre = match[2];\n            attributeValuePost = /^[^\">]*/.exec(tokens[i + 1])[0];\n        }\n        const binding = {\n            attributeName: attributeName,\n            attributeValuePre: attributeValuePre,\n            attributeValuePost: attributeValuePost,\n            expressionIndex: i\n        };\n        bindings.push(binding);\n        if (!withinTag && !withinAttribute) // Add a placeholder text node, so we can find it later. Note we only support one dynamic child text node\n        htmlString += \" \";\n    }\n    const template = $be550d328187eb94$var$parseTemplate(htmlString);\n    return {\n        template: template,\n        elementsToBindings: elementsToBindings\n    };\n}\nfunction $be550d328187eb94$var$traverseAndSetupBindings(dom, elementsToBindings) {\n    const instanceBindings = [];\n    // traverse dom\n    const treeWalker = document.createTreeWalker(dom, NodeFilter.SHOW_ELEMENT);\n    let element = dom;\n    let elementIndex = -1;\n    do {\n        const bindings = elementsToBindings.get(++elementIndex);\n        if (bindings) for(let i = 0; i < bindings.length; i++){\n            const binding = bindings[i];\n            const targetNode = binding.attributeName ? element // attribute binding, just use the element itself\n             : element.firstChild; // not an attribute binding, so has a placeholder text node\n            const instanceBinding = {\n                binding: binding,\n                targetNode: targetNode,\n                targetParentNode: undefined,\n                currentExpression: undefined\n            };\n            instanceBindings.push(instanceBinding);\n        }\n    }while (element = treeWalker.nextNode());\n    return instanceBindings;\n}\nfunction $be550d328187eb94$var$parseHtml(tokens) {\n    // All templates and bound expressions are unique per tokens array\n    const { template: template, elementsToBindings: elementsToBindings } = $be550d328187eb94$var$getFromMap($be550d328187eb94$var$parseCache, tokens, ()=>$be550d328187eb94$var$parse(tokens));\n    // When we parseHtml, we always return a fresh DOM instance ready to be updated\n    const dom = template.cloneNode(true).content.firstElementChild;\n    const instanceBindings = $be550d328187eb94$var$traverseAndSetupBindings(dom, elementsToBindings);\n    return function updateDomInstance(expressions) {\n        $be550d328187eb94$var$patch(expressions, instanceBindings);\n        return dom;\n    };\n}\nfunction $be550d328187eb94$var$createFramework(state) {\n    const domInstances = $be550d328187eb94$var$getFromMap($be550d328187eb94$var$domInstancesCache, state, ()=>new Map());\n    let domInstanceCacheKey = $be550d328187eb94$var$unkeyedSymbol;\n    function html(tokens, ...expressions) {\n        // Each unique lexical usage of map() is considered unique due to the html`` tagged template call it makes,\n        // which has lexically unique tokens. The unkeyed symbol is just used for html`` usage outside of a map().\n        const domInstancesForTokens = $be550d328187eb94$var$getFromMap(domInstances, tokens, ()=>new Map());\n        const updateDomInstance = $be550d328187eb94$var$getFromMap(domInstancesForTokens, domInstanceCacheKey, ()=>$be550d328187eb94$var$parseHtml(tokens));\n        return updateDomInstance(expressions) // update with expressions\n        ;\n    }\n    function map(array, callback, keyFunction) {\n        return array.map((item, index)=>{\n            const originalCacheKey = domInstanceCacheKey;\n            domInstanceCacheKey = keyFunction(item);\n            try {\n                return callback(item, index);\n            } finally{\n                domInstanceCacheKey = originalCacheKey;\n            }\n        });\n    }\n    return {\n        map: map,\n        html: html\n    };\n}\nfunction $be550d328187eb94$var$render(container, state, helpers, events, actions, refs, abortSignal, firstRender) {\n    const { labelWithSkin: labelWithSkin, titleForEmoji: titleForEmoji, unicodeWithSkin: unicodeWithSkin } = helpers;\n    const { html: html, map: map } = $be550d328187eb94$var$createFramework(state);\n    function emojiList(emojis, searchMode, prefix) {\n        return map(emojis, (emoji, i)=>{\n            return html`<button role=\"${searchMode ? \"option\" : \"menuitem\"}\" aria-selected=\"${state.searchMode ? i === state.activeSearchItem : \"\"}\" aria-label=\"${labelWithSkin(emoji, state.currentSkinTone)}\" title=\"${titleForEmoji(emoji)}\" class=\"emoji ${searchMode && i === state.activeSearchItem ? \"active\" : \"\"}\" id=\"${`${prefix}-${emoji.id}`}\">${emoji.unicode ? unicodeWithSkin(emoji, state.currentSkinTone) : html`<img class=\"custom-emoji\" src=\"${emoji.url}\" alt=\"\" loading=\"lazy\">`}</button>`;\n        // It's important for the cache key to be unique based on the prefix, because the framework caches based on the\n        // unique tokens + cache key, and the same emoji may be used in the tab as well as in the fav bar\n        }, (emoji)=>`${prefix}-${emoji.id}`);\n    }\n    const section = ()=>{\n        return html`<section data-ref=\"rootElement\" class=\"picker\" aria-label=\"${state.i18n.regionLabel}\" style=\"${state.pickerStyle}\"><div class=\"pad-top\"></div><div class=\"search-row\"><div class=\"search-wrapper\"><input id=\"search\" class=\"search\" type=\"search\" role=\"combobox\" enterkeyhint=\"search\" placeholder=\"${state.i18n.searchLabel}\" autocapitalize=\"none\" autocomplete=\"off\" spellcheck=\"true\" aria-expanded=\"${!!(state.searchMode && state.currentEmojis.length)}\" aria-controls=\"search-results\" aria-describedby=\"search-description\" aria-autocomplete=\"list\" aria-activedescendant=\"${state.activeSearchItemId ? `emo-${state.activeSearchItemId}` : \"\"}\" data-ref=\"searchElement\" data-on-input=\"onSearchInput\" data-on-keydown=\"onSearchKeydown\"><label class=\"sr-only\" for=\"search\">${state.i18n.searchLabel}</label> <span id=\"search-description\" class=\"sr-only\">${state.i18n.searchDescription}</span></div><div class=\"skintone-button-wrapper ${state.skinTonePickerExpandedAfterAnimation ? \"expanded\" : \"\"}\"><button id=\"skintone-button\" class=\"emoji ${state.skinTonePickerExpanded ? \"hide-focus\" : \"\"}\" aria-label=\"${state.skinToneButtonLabel}\" title=\"${state.skinToneButtonLabel}\" aria-describedby=\"skintone-description\" aria-haspopup=\"listbox\" aria-expanded=\"${state.skinTonePickerExpanded}\" aria-controls=\"skintone-list\" data-on-click=\"onClickSkinToneButton\">${state.skinToneButtonText}</button></div><span id=\"skintone-description\" class=\"sr-only\">${state.i18n.skinToneDescription}</span><div data-ref=\"skinToneDropdown\" id=\"skintone-list\" class=\"skintone-list hide-focus ${state.skinTonePickerExpanded ? \"\" : \"hidden no-animate\"}\" style=\"transform:translateY(${state.skinTonePickerExpanded ? 0 : \"calc(-1 * var(--num-skintones) * var(--total-emoji-size))\"})\" role=\"listbox\" aria-label=\"${state.i18n.skinTonesLabel}\" aria-activedescendant=\"skintone-${state.activeSkinTone}\" aria-hidden=\"${!state.skinTonePickerExpanded}\" tabIndex=\"-1\" data-on-focusout=\"onSkinToneOptionsFocusOut\" data-on-click=\"onSkinToneOptionsClick\" data-on-keydown=\"onSkinToneOptionsKeydown\" data-on-keyup=\"onSkinToneOptionsKeyup\">${map(state.skinTones, (skinTone, i)=>{\n            return html`<div id=\"skintone-${i}\" class=\"emoji ${i === state.activeSkinTone ? \"active\" : \"\"}\" aria-selected=\"${i === state.activeSkinTone}\" role=\"option\" title=\"${state.i18n.skinTones[i]}\" aria-label=\"${state.i18n.skinTones[i]}\">${skinTone}</div>`;\n        }, (skinTone)=>skinTone)}</div></div><div class=\"nav\" role=\"tablist\" style=\"grid-template-columns:repeat(${state.groups.length},1fr)\" aria-label=\"${state.i18n.categoriesLabel}\" data-on-keydown=\"onNavKeydown\" data-on-click=\"onNavClick\">${map(state.groups, (group)=>{\n            return html`<button role=\"tab\" class=\"nav-button\" aria-controls=\"tab-${group.id}\" aria-label=\"${state.i18n.categories[group.name]}\" aria-selected=\"${!state.searchMode && state.currentGroup.id === group.id}\" title=\"${state.i18n.categories[group.name]}\" data-group-id=\"${group.id}\"><div class=\"nav-emoji emoji\">${group.emoji}</div></button>`;\n        }, (group)=>group.id)}</div><div class=\"indicator-wrapper\"><div class=\"indicator\" style=\"transform:translateX(${/* istanbul ignore next */ (state.isRtl ? -1 : 1) * state.currentGroupIndex * 100}%)\"></div></div><div class=\"message ${state.message ? \"\" : \"gone\"}\" role=\"alert\" aria-live=\"polite\">${state.message}</div><div data-ref=\"tabpanelElement\" class=\"tabpanel ${!state.databaseLoaded || state.message ? \"gone\" : \"\"}\" role=\"${state.searchMode ? \"region\" : \"tabpanel\"}\" aria-label=\"${state.searchMode ? state.i18n.searchResultsLabel : state.i18n.categories[state.currentGroup.name]}\" id=\"${state.searchMode ? \"\" : `tab-${state.currentGroup.id}`}\" tabIndex=\"0\" data-on-click=\"onEmojiClick\"><div data-action=\"calculateEmojiGridStyle\">${map(state.currentEmojisWithCategories, (emojiWithCategory, i)=>{\n            return html`<div><div id=\"menu-label-${i}\" class=\"category ${state.currentEmojisWithCategories.length === 1 && state.currentEmojisWithCategories[0].category === \"\" ? \"gone\" : \"\"}\" aria-hidden=\"true\">${state.searchMode ? state.i18n.searchResultsLabel : emojiWithCategory.category ? emojiWithCategory.category : state.currentEmojisWithCategories.length > 1 ? state.i18n.categories.custom : state.i18n.categories[state.currentGroup.name]}</div><div class=\"emoji-menu\" role=\"${state.searchMode ? \"listbox\" : \"menu\"}\" aria-labelledby=\"menu-label-${i}\" id=\"${state.searchMode ? \"search-results\" : \"\"}\">${emojiList(emojiWithCategory.emojis, state.searchMode, /* prefix */ \"emo\")}</div></div>`;\n        }, (emojiWithCategory)=>emojiWithCategory.category)}</div></div><div class=\"favorites emoji-menu ${state.message ? \"gone\" : \"\"}\" role=\"menu\" aria-label=\"${state.i18n.favoritesLabel}\" style=\"padding-inline-end:${`${state.scrollbarWidth}px`}\" data-on-click=\"onEmojiClick\">${emojiList(state.currentFavorites, /* searchMode */ false, /* prefix */ \"fav\")}</div><button data-ref=\"baselineEmoji\" aria-hidden=\"true\" tabindex=\"-1\" class=\"abs-pos hidden emoji baseline-emoji\"></button></section>`;\n    };\n    const rootDom = section();\n    if (firstRender) {\n        container.appendChild(rootDom);\n        // we only bind events/refs/actions once - there is no need to find them again given this component structure\n        // helper for traversing the dom, finding elements by an attribute, and getting the attribute value\n        const forElementWithAttribute = (attributeName, callback)=>{\n            for (const element of container.querySelectorAll(`[${attributeName}]`))callback(element, element.getAttribute(attributeName));\n        };\n        // bind events\n        for (const eventName of [\n            \"click\",\n            \"focusout\",\n            \"input\",\n            \"keydown\",\n            \"keyup\"\n        ])forElementWithAttribute(`data-on-${eventName}`, (element, listenerName)=>{\n            element.addEventListener(eventName, events[listenerName]);\n        });\n        // find refs\n        forElementWithAttribute(\"data-ref\", (element, ref)=>{\n            refs[ref] = element;\n        });\n        // set up actions\n        forElementWithAttribute(\"data-action\", (element, action)=>{\n            actions[action](element);\n        });\n        // destroy/abort logic\n        abortSignal.addEventListener(\"abort\", ()=>{\n            container.removeChild(rootDom);\n        });\n    }\n}\n/* istanbul ignore next */ const $be550d328187eb94$var$qM = typeof queueMicrotask === \"function\" ? queueMicrotask : (callback)=>Promise.resolve().then(callback);\nfunction $be550d328187eb94$var$createState(abortSignal) {\n    let destroyed = false;\n    let currentObserver;\n    const propsToObservers = new Map();\n    const dirtyObservers = new Set();\n    let queued;\n    const flush = ()=>{\n        if (destroyed) return;\n        const observersToRun = [\n            ...dirtyObservers\n        ];\n        dirtyObservers.clear(); // clear before running to force any new updates to run in another tick of the loop\n        try {\n            for (const observer of observersToRun)observer();\n        } finally{\n            queued = false;\n            if (dirtyObservers.size) {\n                queued = true;\n                $be550d328187eb94$var$qM(flush);\n            }\n        }\n    };\n    const state = new Proxy({}, {\n        get (target, prop) {\n            if (currentObserver) {\n                let observers = propsToObservers.get(prop);\n                if (!observers) {\n                    observers = new Set();\n                    propsToObservers.set(prop, observers);\n                }\n                observers.add(currentObserver);\n            }\n            return target[prop];\n        },\n        set (target, prop, newValue) {\n            target[prop] = newValue;\n            const observers = propsToObservers.get(prop);\n            if (observers) {\n                for (const observer of observers)dirtyObservers.add(observer);\n                if (!queued) {\n                    queued = true;\n                    $be550d328187eb94$var$qM(flush);\n                }\n            }\n            return true;\n        }\n    });\n    const createEffect = (callback)=>{\n        const runnable = ()=>{\n            const oldObserver = currentObserver;\n            currentObserver = runnable;\n            try {\n                return callback();\n            } finally{\n                currentObserver = oldObserver;\n            }\n        };\n        return runnable();\n    };\n    // destroy logic\n    abortSignal.addEventListener(\"abort\", ()=>{\n        destroyed = true;\n    });\n    return {\n        state: state,\n        createEffect: createEffect\n    };\n}\n// Compare two arrays, with a function called on each item in the two arrays that returns true if the items are equal\nfunction $be550d328187eb94$var$arraysAreEqualByFunction(left, right, areEqualFunc) {\n    if (left.length !== right.length) return false;\n    for(let i = 0; i < left.length; i++){\n        if (!areEqualFunc(left[i], right[i])) return false;\n    }\n    return true;\n}\n/* eslint-disable prefer-const,no-labels,no-inner-declarations */ // constants\nconst $be550d328187eb94$var$EMPTY_ARRAY = [];\nconst { assign: $be550d328187eb94$var$assign } = Object;\nfunction $be550d328187eb94$var$createRoot(shadowRoot, props) {\n    const refs = {};\n    const abortController = new AbortController();\n    const abortSignal = abortController.signal;\n    const { state: state, createEffect: createEffect } = $be550d328187eb94$var$createState(abortSignal);\n    // initial state\n    $be550d328187eb94$var$assign(state, {\n        skinToneEmoji: undefined,\n        i18n: undefined,\n        database: undefined,\n        customEmoji: undefined,\n        customCategorySorting: undefined,\n        emojiVersion: undefined\n    });\n    // public props\n    $be550d328187eb94$var$assign(state, props);\n    // private props\n    $be550d328187eb94$var$assign(state, {\n        initialLoad: true,\n        currentEmojis: [],\n        currentEmojisWithCategories: [],\n        rawSearchText: \"\",\n        searchText: \"\",\n        searchMode: false,\n        activeSearchItem: -1,\n        message: undefined,\n        skinTonePickerExpanded: false,\n        skinTonePickerExpandedAfterAnimation: false,\n        currentSkinTone: 0,\n        activeSkinTone: 0,\n        skinToneButtonText: undefined,\n        pickerStyle: undefined,\n        skinToneButtonLabel: \"\",\n        skinTones: [],\n        currentFavorites: [],\n        defaultFavoriteEmojis: undefined,\n        numColumns: $be550d328187eb94$var$DEFAULT_NUM_COLUMNS,\n        isRtl: false,\n        scrollbarWidth: 0,\n        currentGroupIndex: 0,\n        groups: $be550d328187eb94$var$groups,\n        databaseLoaded: false,\n        activeSearchItemId: undefined\n    });\n    //\n    // Update the current group based on the currentGroupIndex\n    //\n    createEffect(()=>{\n        if (state.currentGroup !== state.groups[state.currentGroupIndex]) state.currentGroup = state.groups[state.currentGroupIndex];\n    });\n    //\n    // Utils/helpers\n    //\n    const focus = (id)=>{\n        shadowRoot.getElementById(id).focus();\n    };\n    const emojiToDomNode = (emoji)=>shadowRoot.getElementById(`emo-${emoji.id}`);\n    // fire a custom event that crosses the shadow boundary\n    const fireEvent = (name, detail)=>{\n        refs.rootElement.dispatchEvent(new CustomEvent(name, {\n            detail: detail,\n            bubbles: true,\n            composed: true\n        }));\n    };\n    //\n    // Comparison utils\n    //\n    const compareEmojiArrays = (a, b)=>a.id === b.id;\n    const compareCurrentEmojisWithCategories = (a, b)=>{\n        const { category: aCategory, emojis: aEmojis } = a;\n        const { category: bCategory, emojis: bEmojis } = b;\n        if (aCategory !== bCategory) return false;\n        return $be550d328187eb94$var$arraysAreEqualByFunction(aEmojis, bEmojis, compareEmojiArrays);\n    };\n    //\n    // Update utils to avoid excessive re-renders\n    //\n    // avoid excessive re-renders by checking the value before setting\n    const updateCurrentEmojis = (newEmojis)=>{\n        if (!$be550d328187eb94$var$arraysAreEqualByFunction(state.currentEmojis, newEmojis, compareEmojiArrays)) state.currentEmojis = newEmojis;\n    };\n    // avoid excessive re-renders\n    const updateSearchMode = (newSearchMode)=>{\n        if (state.searchMode !== newSearchMode) state.searchMode = newSearchMode;\n    };\n    // avoid excessive re-renders\n    const updateCurrentEmojisWithCategories = (newEmojisWithCategories)=>{\n        if (!$be550d328187eb94$var$arraysAreEqualByFunction(state.currentEmojisWithCategories, newEmojisWithCategories, compareCurrentEmojisWithCategories)) state.currentEmojisWithCategories = newEmojisWithCategories;\n    };\n    // Helpers used by PickerTemplate\n    const unicodeWithSkin = (emoji, currentSkinTone)=>currentSkinTone && emoji.skins && emoji.skins[currentSkinTone] || emoji.unicode;\n    const labelWithSkin = (emoji, currentSkinTone)=>$be550d328187eb94$var$uniq([\n            emoji.name || unicodeWithSkin(emoji, currentSkinTone),\n            emoji.annotation,\n            ...emoji.shortcodes || $be550d328187eb94$var$EMPTY_ARRAY\n        ].filter(Boolean)).join(\", \");\n    const titleForEmoji = (emoji)=>emoji.annotation || (emoji.shortcodes || $be550d328187eb94$var$EMPTY_ARRAY).join(\", \");\n    const helpers = {\n        labelWithSkin: labelWithSkin,\n        titleForEmoji: titleForEmoji,\n        unicodeWithSkin: unicodeWithSkin\n    };\n    const events = {\n        onClickSkinToneButton: onClickSkinToneButton,\n        onEmojiClick: onEmojiClick,\n        onNavClick: onNavClick,\n        onNavKeydown: onNavKeydown,\n        onSearchKeydown: onSearchKeydown,\n        onSkinToneOptionsClick: onSkinToneOptionsClick,\n        onSkinToneOptionsFocusOut: onSkinToneOptionsFocusOut,\n        onSkinToneOptionsKeydown: onSkinToneOptionsKeydown,\n        onSkinToneOptionsKeyup: onSkinToneOptionsKeyup,\n        onSearchInput: onSearchInput\n    };\n    const actions = {\n        calculateEmojiGridStyle: calculateEmojiGridStyle\n    };\n    let firstRender = true;\n    createEffect(()=>{\n        $be550d328187eb94$var$render(shadowRoot, state, helpers, events, actions, refs, abortSignal, firstRender);\n        firstRender = false;\n    });\n    //\n    // Determine the emoji support level (in requestIdleCallback)\n    //\n    // mount logic\n    if (!state.emojiVersion) $be550d328187eb94$var$detectEmojiSupportLevel().then((level)=>{\n        // Can't actually test emoji support in Jest/Vitest/JSDom, emoji never render in color in Cairo\n        /* istanbul ignore next */ if (!level) state.message = state.i18n.emojiUnsupportedMessage;\n    });\n    //\n    // Set or update the database object\n    //\n    createEffect(()=>{\n        // show a Loading message if it takes a long time, or show an error if there's a network/IDB error\n        async function handleDatabaseLoading() {\n            let showingLoadingMessage = false;\n            const timeoutHandle = setTimeout(()=>{\n                showingLoadingMessage = true;\n                state.message = state.i18n.loadingMessage;\n            }, $be550d328187eb94$var$TIMEOUT_BEFORE_LOADING_MESSAGE);\n            try {\n                await state.database.ready();\n                state.databaseLoaded = true; // eslint-disable-line no-unused-vars\n            } catch (err) {\n                console.error(err);\n                state.message = state.i18n.networkErrorMessage;\n            } finally{\n                clearTimeout(timeoutHandle);\n                if (showingLoadingMessage) {\n                    showingLoadingMessage = false;\n                    state.message = \"\"; // eslint-disable-line no-unused-vars\n                }\n            }\n        }\n        if (state.database) /* no await */ handleDatabaseLoading();\n    });\n    //\n    // Global styles for the entire picker\n    //\n    createEffect(()=>{\n        state.pickerStyle = `\n      --num-groups: ${state.groups.length}; \n      --indicator-opacity: ${state.searchMode ? 0 : 1}; \n      --num-skintones: ${$be550d328187eb94$var$NUM_SKIN_TONES};`;\n    });\n    //\n    // Set or update the customEmoji\n    //\n    createEffect(()=>{\n        if (state.customEmoji && state.database) updateCustomEmoji(); // re-run whenever customEmoji change\n    });\n    createEffect(()=>{\n        if (state.customEmoji && state.customEmoji.length) {\n            if (state.groups !== $be550d328187eb94$var$allGroups) state.groups = $be550d328187eb94$var$allGroups;\n        } else if (state.groups !== $be550d328187eb94$var$groups) {\n            if (state.currentGroupIndex) // If the current group is anything other than \"custom\" (which is first), decrement.\n            // This fixes the odd case where you set customEmoji, then pick a category, then unset customEmoji\n            state.currentGroupIndex--;\n            state.groups = $be550d328187eb94$var$groups;\n        }\n    });\n    //\n    // Set or update the preferred skin tone\n    //\n    createEffect(()=>{\n        async function updatePreferredSkinTone() {\n            if (state.databaseLoaded) state.currentSkinTone = await state.database.getPreferredSkinTone();\n        }\n        /* no await */ updatePreferredSkinTone();\n    });\n    createEffect(()=>{\n        state.skinTones = Array($be550d328187eb94$var$NUM_SKIN_TONES).fill().map((_, i)=>$be550d328187eb94$var$applySkinTone(state.skinToneEmoji, i));\n    });\n    createEffect(()=>{\n        state.skinToneButtonText = state.skinTones[state.currentSkinTone];\n    });\n    createEffect(()=>{\n        state.skinToneButtonLabel = state.i18n.skinToneLabel.replace(\"{skinTone}\", state.i18n.skinTones[state.currentSkinTone]);\n    });\n    //\n    // Set or update the favorites emojis\n    //\n    createEffect(()=>{\n        async function updateDefaultFavoriteEmojis() {\n            const { database: database } = state;\n            const favs = (await Promise.all($be550d328187eb94$var$MOST_COMMONLY_USED_EMOJI.map((unicode)=>database.getEmojiByUnicodeOrName(unicode)))).filter(Boolean); // filter because in Jest/Vitest tests we don't have all the emoji in the DB\n            state.defaultFavoriteEmojis = favs;\n        }\n        if (state.databaseLoaded) /* no await */ updateDefaultFavoriteEmojis();\n    });\n    function updateCustomEmoji() {\n        // Certain effects have an implicit dependency on customEmoji since it affects the database\n        // Getting it here on the state ensures this effect re-runs when customEmoji change.\n        // Setting it on the database is pointless but prevents this code from being removed by a minifier.\n        state.database.customEmoji = state.customEmoji || $be550d328187eb94$var$EMPTY_ARRAY;\n    }\n    createEffect(()=>{\n        async function updateFavorites() {\n            updateCustomEmoji(); // re-run whenever customEmoji change\n            const { database: database, defaultFavoriteEmojis: defaultFavoriteEmojis, numColumns: numColumns } = state;\n            const dbFavorites = await database.getTopFavoriteEmoji(numColumns);\n            const favorites = await summarizeEmojis($be550d328187eb94$var$uniqBy([\n                ...dbFavorites,\n                ...defaultFavoriteEmojis\n            ], (_)=>_.unicode || _.name).slice(0, numColumns));\n            state.currentFavorites = favorites;\n        }\n        if (state.databaseLoaded && state.defaultFavoriteEmojis) /* no await */ updateFavorites();\n    });\n    //\n    // Calculate the width of the emoji grid. This serves two purposes:\n    // 1) Re-calculate the --num-columns var because it may have changed\n    // 2) Re-calculate the scrollbar width because it may have changed\n    //   (i.e. because the number of items changed)\n    // 3) Re-calculate whether we're in RTL mode or not.\n    //\n    // The benefit of doing this in one place is to align with rAF/ResizeObserver\n    // and do all the calculations in one go. RTL vs LTR is not strictly width-related,\n    // but since we're already reading the style here, and since it's already aligned with\n    // the rAF loop, this is the most appropriate place to do it perf-wise.\n    //\n    function calculateEmojiGridStyle(node) {\n        $be550d328187eb94$var$calculateWidth(node, abortSignal, (width)=>{\n            /* istanbul ignore next */ {\n                // read all the style/layout calculations we need to make\n                const style = getComputedStyle(refs.rootElement);\n                const newNumColumns = parseInt(style.getPropertyValue(\"--num-columns\"), 10);\n                const newIsRtl = style.getPropertyValue(\"direction\") === \"rtl\";\n                const parentWidth = node.parentElement.getBoundingClientRect().width;\n                const newScrollbarWidth = parentWidth - width;\n                // write to state variables\n                state.numColumns = newNumColumns;\n                state.scrollbarWidth = newScrollbarWidth; // eslint-disable-line no-unused-vars\n                state.isRtl = newIsRtl; // eslint-disable-line no-unused-vars\n            }\n        });\n    }\n    //\n    // Set or update the currentEmojis. Check for invalid ZWJ renderings\n    // (i.e. double emoji).\n    //\n    createEffect(()=>{\n        async function updateEmojis() {\n            const { searchText: searchText, currentGroup: currentGroup, databaseLoaded: databaseLoaded, customEmoji: customEmoji } = state;\n            if (!databaseLoaded) {\n                state.currentEmojis = [];\n                state.searchMode = false;\n            } else if (searchText.length >= $be550d328187eb94$var$MIN_SEARCH_TEXT_LENGTH) {\n                const newEmojis = await getEmojisBySearchQuery(searchText);\n                if (state.searchText === searchText) {\n                    updateCurrentEmojis(newEmojis);\n                    updateSearchMode(true);\n                }\n            } else {\n                const { id: currentGroupId } = currentGroup;\n                // avoid race condition where currentGroupId is -1 and customEmoji is undefined/empty\n                if (currentGroupId !== -1 || customEmoji && customEmoji.length) {\n                    const newEmojis = await getEmojisByGroup(currentGroupId);\n                    if (state.currentGroup.id === currentGroupId) {\n                        updateCurrentEmojis(newEmojis);\n                        updateSearchMode(false);\n                    }\n                }\n            }\n        }\n        /* no await */ updateEmojis();\n    });\n    // Some emojis have their ligatures rendered as two or more consecutive emojis\n    // We want to treat these the same as unsupported emojis, so we compare their\n    // widths against the baseline widths and remove them as necessary\n    createEffect(()=>{\n        const { currentEmojis: currentEmojis, emojiVersion: emojiVersion } = state;\n        const zwjEmojisToCheck = currentEmojis.filter((emoji)=>emoji.unicode) // filter custom emoji\n        .filter((emoji)=>$be550d328187eb94$var$hasZwj(emoji) && !$be550d328187eb94$var$supportedZwjEmojis.has(emoji.unicode));\n        if (!emojiVersion && zwjEmojisToCheck.length) {\n            // render now, check their length later\n            updateCurrentEmojis(currentEmojis);\n            $be550d328187eb94$var$rAF(()=>checkZwjSupportAndUpdate(zwjEmojisToCheck));\n        } else {\n            const newEmojis = emojiVersion ? currentEmojis : currentEmojis.filter(isZwjSupported);\n            updateCurrentEmojis(newEmojis);\n            // Reset scroll top to 0 when emojis change\n            $be550d328187eb94$var$rAF(()=>$be550d328187eb94$var$resetScrollTopIfPossible(refs.tabpanelElement));\n        }\n    });\n    function checkZwjSupportAndUpdate(zwjEmojisToCheck) {\n        $be550d328187eb94$var$checkZwjSupport(zwjEmojisToCheck, refs.baselineEmoji, emojiToDomNode);\n        // force update\n        // eslint-disable-next-line no-self-assign\n        state.currentEmojis = state.currentEmojis;\n    }\n    function isZwjSupported(emoji) {\n        return !emoji.unicode || !$be550d328187eb94$var$hasZwj(emoji) || $be550d328187eb94$var$supportedZwjEmojis.get(emoji.unicode);\n    }\n    async function filterEmojisByVersion(emojis) {\n        const emojiSupportLevel = state.emojiVersion || await $be550d328187eb94$var$detectEmojiSupportLevel();\n        // !version corresponds to custom emoji\n        return emojis.filter(({ version: version })=>!version || version <= emojiSupportLevel);\n    }\n    async function summarizeEmojis(emojis) {\n        return $be550d328187eb94$var$summarizeEmojisForUI(emojis, state.emojiVersion || await $be550d328187eb94$var$detectEmojiSupportLevel());\n    }\n    async function getEmojisByGroup(group) {\n        // -1 is custom emoji\n        const emoji = group === -1 ? state.customEmoji : await state.database.getEmojiByGroup(group);\n        return summarizeEmojis(await filterEmojisByVersion(emoji));\n    }\n    async function getEmojisBySearchQuery(query) {\n        return summarizeEmojis(await filterEmojisByVersion(await state.database.getEmojiBySearchQuery(query)));\n    }\n    createEffect(()=>{});\n    //\n    // Derive currentEmojisWithCategories from currentEmojis. This is always done even if there\n    // are no categories, because it's just easier to code the HTML this way.\n    //\n    createEffect(()=>{\n        function calculateCurrentEmojisWithCategories() {\n            const { searchMode: searchMode, currentEmojis: currentEmojis } = state;\n            if (searchMode) return [\n                {\n                    category: \"\",\n                    emojis: currentEmojis\n                }\n            ];\n            const categoriesToEmoji = new Map();\n            for (const emoji of currentEmojis){\n                const category = emoji.category || \"\";\n                let emojis = categoriesToEmoji.get(category);\n                if (!emojis) {\n                    emojis = [];\n                    categoriesToEmoji.set(category, emojis);\n                }\n                emojis.push(emoji);\n            }\n            return [\n                ...categoriesToEmoji.entries()\n            ].map(([category, emojis])=>({\n                    category: category,\n                    emojis: emojis\n                })).sort((a, b)=>state.customCategorySorting(a.category, b.category));\n        }\n        const newEmojisWithCategories = calculateCurrentEmojisWithCategories();\n        updateCurrentEmojisWithCategories(newEmojisWithCategories);\n    });\n    //\n    // Handle active search item (i.e. pressing up or down while searching)\n    //\n    createEffect(()=>{\n        state.activeSearchItemId = state.activeSearchItem !== -1 && state.currentEmojis[state.activeSearchItem].id;\n    });\n    //\n    // Handle user input on the search input\n    //\n    createEffect(()=>{\n        const { rawSearchText: rawSearchText } = state;\n        $be550d328187eb94$var$rIC(()=>{\n            state.searchText = (rawSearchText || \"\").trim(); // defer to avoid input delays, plus we can trim here\n            state.activeSearchItem = -1;\n        });\n    });\n    function onSearchKeydown(event) {\n        if (!state.searchMode || !state.currentEmojis.length) return;\n        const goToNextOrPrevious = (previous)=>{\n            $be550d328187eb94$var$halt(event);\n            state.activeSearchItem = $be550d328187eb94$var$incrementOrDecrement(previous, state.activeSearchItem, state.currentEmojis);\n        };\n        switch(event.key){\n            case \"ArrowDown\":\n                return goToNextOrPrevious(false);\n            case \"ArrowUp\":\n                return goToNextOrPrevious(true);\n            case \"Enter\":\n                if (state.activeSearchItem === -1) // focus the first option in the list since the list must be non-empty at this point (it's verified above)\n                state.activeSearchItem = 0;\n                else {\n                    $be550d328187eb94$var$halt(event);\n                    return clickEmoji(state.currentEmojis[state.activeSearchItem].id);\n                }\n        }\n    }\n    //\n    // Handle user input on nav\n    //\n    function onNavClick(event) {\n        const { target: target } = event;\n        const closestTarget = target.closest(\".nav-button\");\n        /* istanbul ignore if */ if (!closestTarget) return; // This should never happen, but makes me nervous not to have it\n        const groupId = parseInt(closestTarget.dataset.groupId, 10);\n        refs.searchElement.value = \"\"; // clear search box input\n        state.rawSearchText = \"\";\n        state.searchText = \"\";\n        state.activeSearchItem = -1;\n        state.currentGroupIndex = state.groups.findIndex((_)=>_.id === groupId);\n    }\n    function onNavKeydown(event) {\n        const { target: target, key: key } = event;\n        const doFocus = (el)=>{\n            if (el) {\n                $be550d328187eb94$var$halt(event);\n                el.focus();\n            }\n        };\n        switch(key){\n            case \"ArrowLeft\":\n                return doFocus(target.previousElementSibling);\n            case \"ArrowRight\":\n                return doFocus(target.nextElementSibling);\n            case \"Home\":\n                return doFocus(target.parentElement.firstElementChild);\n            case \"End\":\n                return doFocus(target.parentElement.lastElementChild);\n        }\n    }\n    //\n    // Handle user input on an emoji\n    //\n    async function clickEmoji(unicodeOrName) {\n        const emoji = await state.database.getEmojiByUnicodeOrName(unicodeOrName);\n        const emojiSummary = [\n            ...state.currentEmojis,\n            ...state.currentFavorites\n        ].find((_)=>_.id === unicodeOrName);\n        const skinTonedUnicode = emojiSummary.unicode && unicodeWithSkin(emojiSummary, state.currentSkinTone);\n        await state.database.incrementFavoriteEmojiCount(unicodeOrName);\n        fireEvent(\"emoji-click\", {\n            emoji: emoji,\n            skinTone: state.currentSkinTone,\n            ...skinTonedUnicode && {\n                unicode: skinTonedUnicode\n            },\n            ...emojiSummary.name && {\n                name: emojiSummary.name\n            }\n        });\n    }\n    async function onEmojiClick(event) {\n        const { target: target } = event;\n        /* istanbul ignore if */ if (!target.classList.contains(\"emoji\")) // This should never happen, but makes me nervous not to have it\n        return;\n        $be550d328187eb94$var$halt(event);\n        const id = target.id.substring(4); // replace 'emo-' or 'fav-' prefix\n        /* no await */ clickEmoji(id);\n    }\n    //\n    // Handle user input on the skintone picker\n    //\n    function changeSkinTone(skinTone) {\n        state.currentSkinTone = skinTone;\n        state.skinTonePickerExpanded = false;\n        focus(\"skintone-button\");\n        fireEvent(\"skin-tone-change\", {\n            skinTone: skinTone\n        });\n        /* no await */ state.database.setPreferredSkinTone(skinTone);\n    }\n    function onSkinToneOptionsClick(event) {\n        const { target: { id: id } } = event;\n        const match = id && id.match(/^skintone-(\\d)/); // skintone option format\n        /* istanbul ignore if */ if (!match) return; // This should never happen, but makes me nervous not to have it\n        $be550d328187eb94$var$halt(event);\n        const skinTone = parseInt(match[1], 10); // remove 'skintone-' prefix\n        changeSkinTone(skinTone);\n    }\n    function onClickSkinToneButton(event) {\n        state.skinTonePickerExpanded = !state.skinTonePickerExpanded;\n        state.activeSkinTone = state.currentSkinTone;\n        // this should always be true, since the button is obscured by the listbox, so this `if` is just to be sure\n        if (state.skinTonePickerExpanded) {\n            $be550d328187eb94$var$halt(event);\n            $be550d328187eb94$var$rAF(()=>focus(\"skintone-list\"));\n        }\n    }\n    // To make the animation nicer, change the z-index of the skintone picker button\n    // *after* the animation has played. This makes it appear that the picker box\n    // is expanding \"below\" the button\n    createEffect(()=>{\n        if (state.skinTonePickerExpanded) refs.skinToneDropdown.addEventListener(\"transitionend\", ()=>{\n            state.skinTonePickerExpandedAfterAnimation = true; // eslint-disable-line no-unused-vars\n        }, {\n            once: true\n        });\n        else state.skinTonePickerExpandedAfterAnimation = false; // eslint-disable-line no-unused-vars\n    });\n    function onSkinToneOptionsKeydown(event) {\n        // this should never happen, but makes me nervous not to have it\n        /* istanbul ignore if */ if (!state.skinTonePickerExpanded) return;\n        const changeActiveSkinTone = async (nextSkinTone)=>{\n            $be550d328187eb94$var$halt(event);\n            state.activeSkinTone = nextSkinTone;\n        };\n        switch(event.key){\n            case \"ArrowUp\":\n                return changeActiveSkinTone($be550d328187eb94$var$incrementOrDecrement(true, state.activeSkinTone, state.skinTones));\n            case \"ArrowDown\":\n                return changeActiveSkinTone($be550d328187eb94$var$incrementOrDecrement(false, state.activeSkinTone, state.skinTones));\n            case \"Home\":\n                return changeActiveSkinTone(0);\n            case \"End\":\n                return changeActiveSkinTone(state.skinTones.length - 1);\n            case \"Enter\":\n                // enter on keydown, space on keyup. this is just how browsers work for buttons\n                // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n                $be550d328187eb94$var$halt(event);\n                return changeSkinTone(state.activeSkinTone);\n            case \"Escape\":\n                $be550d328187eb94$var$halt(event);\n                state.skinTonePickerExpanded = false;\n                return focus(\"skintone-button\");\n        }\n    }\n    function onSkinToneOptionsKeyup(event) {\n        // this should never happen, but makes me nervous not to have it\n        /* istanbul ignore if */ if (!state.skinTonePickerExpanded) return;\n        switch(event.key){\n            case \" \":\n                // enter on keydown, space on keyup. this is just how browsers work for buttons\n                // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n                $be550d328187eb94$var$halt(event);\n                return changeSkinTone(state.activeSkinTone);\n        }\n    }\n    async function onSkinToneOptionsFocusOut(event) {\n        // On blur outside of the skintone listbox, collapse the skintone picker.\n        const { relatedTarget: relatedTarget } = event;\n        // The `else` should never happen, but makes me nervous not to have it\n        /* istanbul ignore else */ if (!relatedTarget || relatedTarget.id !== \"skintone-list\") state.skinTonePickerExpanded = false;\n    }\n    function onSearchInput(event) {\n        state.rawSearchText = event.target.value;\n    }\n    return {\n        $set (newState) {\n            $be550d328187eb94$var$assign(state, newState);\n        },\n        $destroy () {\n            abortController.abort();\n        }\n    };\n}\nconst $be550d328187eb94$var$DEFAULT_DATA_SOURCE = \"https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json\";\nconst $be550d328187eb94$var$DEFAULT_LOCALE = \"en\";\nvar $be550d328187eb94$var$enI18n = {\n    categoriesLabel: \"Categories\",\n    emojiUnsupportedMessage: \"Your browser does not support color emoji.\",\n    favoritesLabel: \"Favorites\",\n    loadingMessage: \"Loading\\u2026\",\n    networkErrorMessage: \"Could not load emoji.\",\n    regionLabel: \"Emoji picker\",\n    searchDescription: \"When search results are available, press up or down to select and enter to choose.\",\n    searchLabel: \"Search\",\n    searchResultsLabel: \"Search results\",\n    skinToneDescription: \"When expanded, press up or down to select and enter to choose.\",\n    skinToneLabel: \"Choose a skin tone (currently {skinTone})\",\n    skinTonesLabel: \"Skin tones\",\n    skinTones: [\n        \"Default\",\n        \"Light\",\n        \"Medium-Light\",\n        \"Medium\",\n        \"Medium-Dark\",\n        \"Dark\"\n    ],\n    categories: {\n        custom: \"Custom\",\n        \"smileys-emotion\": \"Smileys and emoticons\",\n        \"people-body\": \"People and body\",\n        \"animals-nature\": \"Animals and nature\",\n        \"food-drink\": \"Food and drink\",\n        \"travel-places\": \"Travel and places\",\n        activities: \"Activities\",\n        objects: \"Objects\",\n        symbols: \"Symbols\",\n        flags: \"Flags\"\n    }\n};\nvar $be550d328187eb94$var$baseStyles = \":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}\";\nconst $be550d328187eb94$var$PROPS = [\n    \"customEmoji\",\n    \"customCategorySorting\",\n    \"database\",\n    \"dataSource\",\n    \"i18n\",\n    \"locale\",\n    \"skinToneEmoji\",\n    \"emojiVersion\"\n];\n// Styles injected ourselves, so we can declare the FONT_FAMILY variable in one place\nconst $be550d328187eb94$var$EXTRA_STYLES = `:host{--emoji-font-family:${$be550d328187eb94$var$FONT_FAMILY}}`;\nclass $be550d328187eb94$export$2e2bcd8739ae039 extends HTMLElement {\n    constructor(props){\n        super();\n        this.attachShadow({\n            mode: \"open\"\n        });\n        const style = document.createElement(\"style\");\n        style.textContent = $be550d328187eb94$var$baseStyles + $be550d328187eb94$var$EXTRA_STYLES;\n        this.shadowRoot.appendChild(style);\n        this._ctx = {\n            // Set defaults\n            locale: $be550d328187eb94$var$DEFAULT_LOCALE,\n            dataSource: $be550d328187eb94$var$DEFAULT_DATA_SOURCE,\n            skinToneEmoji: $be550d328187eb94$var$DEFAULT_SKIN_TONE_EMOJI,\n            customCategorySorting: $be550d328187eb94$var$DEFAULT_CATEGORY_SORTING,\n            customEmoji: null,\n            i18n: $be550d328187eb94$var$enI18n,\n            emojiVersion: null,\n            ...props\n        };\n        // Handle properties set before the element was upgraded\n        for (const prop of $be550d328187eb94$var$PROPS)if (prop !== \"database\" && Object.prototype.hasOwnProperty.call(this, prop)) {\n            this._ctx[prop] = this[prop];\n            delete this[prop];\n        }\n        this._dbFlush(); // wait for a flush before creating the db, in case the user calls e.g. a setter or setAttribute\n    }\n    connectedCallback() {\n        // The _cmp may be defined if the component was immediately disconnected and then reconnected. In that case,\n        // do nothing (preserve the state)\n        if (!this._cmp) this._cmp = $be550d328187eb94$var$createRoot(this.shadowRoot, this._ctx);\n    }\n    disconnectedCallback() {\n        // Check in a microtask if the element is still connected. If so, treat this as a \"move\" rather than a disconnect\n        // Inspired by Vue: https://vuejs.org/guide/extras/web-components.html#building-custom-elements-with-vue\n        $be550d328187eb94$var$qM(()=>{\n            // this._cmp may be defined if connect-disconnect-connect-disconnect occurs synchronously\n            if (!this.isConnected && this._cmp) {\n                this._cmp.$destroy();\n                this._cmp = undefined;\n                const { database: database } = this._ctx;\n                database.close()// only happens if the database failed to load in the first place, so we don't care\n                .catch((err)=>console.error(err));\n            }\n        });\n    }\n    static get observedAttributes() {\n        return [\n            \"locale\",\n            \"data-source\",\n            \"skin-tone-emoji\",\n            \"emoji-version\"\n        ] // complex objects aren't supported, also use kebab-case\n        ;\n    }\n    attributeChangedCallback(attrName, oldValue, newValue) {\n        this._set(// convert from kebab-case to camelcase\n        // see https://github.com/sveltejs/svelte/issues/3852#issuecomment-665037015\n        attrName.replace(/-([a-z])/g, (_, up)=>up.toUpperCase()), // convert string attribute to float if necessary\n        attrName === \"emoji-version\" ? parseFloat(newValue) : newValue);\n    }\n    _set(prop, newValue) {\n        this._ctx[prop] = newValue;\n        if (this._cmp) this._cmp.$set({\n            [prop]: newValue\n        });\n        if ([\n            \"locale\",\n            \"dataSource\"\n        ].includes(prop)) this._dbFlush();\n    }\n    _dbCreate() {\n        const { locale: locale, dataSource: dataSource, database: database } = this._ctx;\n        // only create a new database if we really need to\n        if (!database || database.locale !== locale || database.dataSource !== dataSource) this._set(\"database\", new (0, $f19b912d87716459$export$2e2bcd8739ae039)({\n            locale: locale,\n            dataSource: dataSource\n        }));\n    }\n    // Update the Database in one microtask if the locale/dataSource change. We do one microtask\n    // so we don't create two Databases if e.g. both the locale and the dataSource change\n    _dbFlush() {\n        $be550d328187eb94$var$qM(()=>this._dbCreate());\n    }\n}\nconst $be550d328187eb94$var$definitions = {};\nfor (const prop of $be550d328187eb94$var$PROPS)$be550d328187eb94$var$definitions[prop] = {\n    get () {\n        if (prop === \"database\") // in rare cases, the microtask may not be flushed yet, so we need to instantiate the DB\n        // now if the user is asking for it\n        this._dbCreate();\n        return this._ctx[prop];\n    },\n    set (val) {\n        if (prop === \"database\") throw new Error(\"database is read-only\");\n        this._set(prop, val);\n    }\n};\nObject.defineProperties($be550d328187eb94$export$2e2bcd8739ae039.prototype, $be550d328187eb94$var$definitions);\n/* istanbul ignore else */ if (!customElements.get(\"emoji-picker\")) customElements.define(\"emoji-picker\", $be550d328187eb94$export$2e2bcd8739ae039);\n\n\n\n\n\nclass $67f00a23dbf3c100$export$74572fb7c2eaec8c extends HTMLElement {\n    query;\n    constructor(){\n        super();\n        this.attachShadow({\n            mode: \"open\"\n        });\n    }\n    connectedCallback() {\n        this.shadowRoot.innerHTML = `<div id=\"responses\"></div>`;\n        this.defaultWhenEmpty(this.shadowRoot.getElementById(\"responses\"));\n    }\n    static get observedAttributes() {\n        return [\n            \"query\"\n        ];\n    }\n    attributeChangedCallback(name, _oldValue, newValue) {\n        if (name === \"query\") {\n            const responses = this.shadowRoot.getElementById(\"responses\");\n            while(responses.firstChild)responses.removeChild(responses.lastChild);\n            if ((0, $a4d41102f2c043db$export$bc00d4d99d9c6e7d).accept(newValue)) {\n                const box = document.createElement(\"mba-box\");\n                const tool = document.createElement((0, $a4d41102f2c043db$export$bc00d4d99d9c6e7d).elmentName());\n                tool.setAttribute(\"query\", newValue);\n                box.appendChild(tool);\n                responses.appendChild(box);\n            }\n            let i = 0;\n            while(i++ < newValue.length){\n                const p = document.createElement(\"p\");\n                p.textContent = newValue + i;\n                responses.appendChild(p);\n            }\n            if (!responses.firstChild) this.defaultWhenEmpty(this.shadowRoot.getElementById(\"responses\"));\n        }\n    }\n    defaultWhenEmpty(responses) {\n        const emoji = document.createElement(\"emoji-picker\");\n        emoji.addEventListener(\"emoji-click\", (event)=>{\n            console.log(event);\n            navigator.clipboard.writeText(event.detail.unicode);\n        });\n        responses.appendChild(emoji);\n    }\n}\n\n\n\ncustomElements.define(\"awesome-bar\", (0, $6bcec25060dd6e92$export$395e24b9a277a1da));\ncustomElements.define(\"mba-responses\", (0, $67f00a23dbf3c100$export$74572fb7c2eaec8c));\ncustomElements.define(\"mba-box\", (0, $7c9734ca8f93e03f$export$46209ca0040d6ae6));\ncustomElements.define((0, $a4d41102f2c043db$export$bc00d4d99d9c6e7d).elmentName(), (0, $a4d41102f2c043db$export$bc00d4d99d9c6e7d));\nconst $f43313d21d3fd8e2$var$responses = document.querySelector(\"mba-responses\");\ndocument.querySelector(\"awesome-bar\").addEventListener(\"change\", (ev)=>{\n    $f43313d21d3fd8e2$var$responses.setAttribute(\"query\", ev.detail);\n});\n\n\n//# sourceMappingURL=index.a35c9996.js.map\n","import { AwesomeBar } from './AwesomeBar';\nimport { BoxResponse } from './BoxRespons';\nimport { Responses } from './Response';\nimport { Numbers } from './tools/Numbers';\n\ncustomElements.define('awesome-bar', AwesomeBar );\ncustomElements.define('mba-responses', Responses );\ncustomElements.define('mba-box', BoxResponse );\ncustomElements.define(Numbers.elmentName(), Numbers );\n\nconst responses = document.querySelector('mba-responses');\n\ndocument.querySelector('awesome-bar')\n    .addEventListener('change', (ev: CustomEvent) => {\n        responses.setAttribute('query', ev.detail);\n    })","export class AwesomeBar extends HTMLElement {\n    query: string;\n\n    constructor() {\n        super();\n        this.attachShadow({mode : 'open' });\n    }\n\n    connectedCallback(): void {\n        this.shadowRoot!.innerHTML = `\n        <style>\n        *,\n        *::before,\n        *::after { \n          box-sizing: border-box;\n        }\n        \n        .input-sizer {\n          display: inline-grid;\n          vertical-align: top;\n          align-items: center;\n          position: relative;\n          border-radius: 10px;\n          padding: .25em .5em;\n          margin: 5px;\n          background-color: var(--nord3);\n          \n          &.stacked {\n            padding: .5em;\n            align-items: stretch;\n            \n            &::after,\n            input,\n            textarea {\n              grid-area: 2 / 1;\n              color: var(--nord6);\n            }\n          }\n          \n          &::after,\n          input,\n          textarea {\n            width: auto;\n            min-width: 1em;\n            grid-area: 1 / 2;\n            font: inherit;\n            padding: 0.25em;\n            margin: 0;\n            resize: none;\n            background: none;\n            appearance: none;\n            border: none;\n          }\n          \n          span {\n            padding: 0.25em;\n          }\n          \n          &::after {\n            content: attr(data-value) ' ';\n            visibility: hidden;\n            white-space: pre-wrap;\n          }\n        }\n        \n        .input-sizer {\n          > span {\n            text-transform: uppercase;\n            font-size: 0.8em;\n            font-weight: bold;\n          }\n        }\n        </style>\n        <div class=\"input-sizer stacked\">\n        <label for=\"name\">Quoi?</label>\n        <textarea oninput=\"this.parentNode.dataset.value = this.value\" rows=\"1\" id=\"name\" name=\"name\"></textarea>\n        </div>`;\n\n        const input = this.shadowRoot!.querySelector('textarea');\n\n        const debounce = (callback, wait: number) => {\n            let timeoutId = null;\n            return (...args: any) => {\n              window.clearTimeout(timeoutId);\n              timeoutId = window.setTimeout(() => callback.apply(null, args), wait);\n            };\n          };\n\n        const handleMouseMove = debounce(() => {\n            this.dispatchEvent(new CustomEvent('change', {detail: input.value}));\n        }, 250);\n\n        input.addEventListener('input', handleMouseMove);\n        input.focus();\n    }\n\n    get value() {\n        let textbox = this.shadowRoot.querySelector(\"input\");\n        return textbox.value;\n    }\n}","const template = document.createElement('template');\ntemplate.innerHTML = `\n<style>\ndiv {\n  background-color: var(--nord3);\n  height: 400px;\n  width: 344px;\n  border: 1px;\n  border-radius: 15px;\n  padding: 1ex;\n}\n</style>\n<div><slot></slot></div>`;\n\nexport class BoxResponse extends HTMLElement {\n    query: string;\n\n    constructor() {\n        super();\n        this.attachShadow({mode : 'open' });\n    }\n\n    connectedCallback(): void {\n        this.shadowRoot.appendChild(template.content.cloneNode(true));\n    }\n}","import { Numbers } from './tools/Numbers';\nimport 'emoji-picker-element';\n\nexport class Responses extends HTMLElement {\n    query: string;\n\n    constructor() {\n        super();\n        this.attachShadow({mode : 'open' });\n    }\n\n    connectedCallback(): void {\n        this.shadowRoot!.innerHTML = `<div id=\"responses\"></div>`;\n        this.defaultWhenEmpty(this.shadowRoot!.getElementById('responses'));\n    }\n\n    static get observedAttributes() {\n        return ['query'];\n    }\n\n    attributeChangedCallback(name: string, _oldValue: string, newValue: string) {\n      if (name === 'query') {\n        const responses = this.shadowRoot!.getElementById('responses');\n        while (responses.firstChild) {\n            responses.removeChild(responses.lastChild);\n        }\n        if (Numbers.accept(newValue)) {\n            const box = document.createElement('mba-box');\n            const tool = document.createElement(Numbers.elmentName());\n            tool.setAttribute('query', newValue);\n            box.appendChild(tool);\n            responses.appendChild(box);\n        }\n\n        let i = 0;\n        while(i++ < newValue.length) {\n            const p = document.createElement('p');\n            p.textContent = newValue + i;\n            responses.appendChild(p);\n        }\n        if (!responses.firstChild) {\n            this.defaultWhenEmpty(this.shadowRoot!.getElementById('responses'));\n        }\n      }\n    }\n\n    defaultWhenEmpty(responses: HTMLElement) {\n        const emoji = document.createElement('emoji-picker');\n        emoji.addEventListener('emoji-click', event => {\n            console.log(event);\n            navigator.clipboard.writeText(event.detail.unicode);\n        });\n        responses.appendChild(emoji);\n    }\n}","export class Numbers extends HTMLElement {\n    query: string;\n\n    constructor() {\n        super();\n        this.attachShadow({mode : 'open' });\n    }\n\n    connectedCallback(): void {\n        const query = this.parse(this.getAttribute('query'));\n        Intl.NumberFormat\n        this.shadowRoot!.innerHTML = `\n            <div>\n                <h2>Number</h2>\n                <dl>\n                    <dt>${query}</dt>\n                    <dd>decimal</dd>\n\n                    <dt>0x${query.toString(16)}</dt>\n                    <dd>hexa</dd>\n\n                    <dt>O${query.toString(2)}</dt>\n                    <dd>binary</dd>\n\n                    <dt>0b${query.toString(8)}</dt>\n                    <dd>octal</dd>\n                </dl>\n            </div>`;\n    }\n\n    private parse(input: string): number {\n        for (const base of [10, 16, 2, 8]) {\n            const r = parseInt(input, base);\n            if (!Number.isNaN(r)) {\n                return r;\n            }\n        }\n        return parseFloat(input);\n    }\n\n    static get observedAttributes(): string[] {\n        return ['query'];\n    }\n\n    public static accept(value: string): boolean {\n        return /^[0-9a-fA-F,. ]+$/.test(value);\n    }\n\n    public static elmentName(): string {\n        return 'mba-tools-numbers';\n    }\n\n    attributeChangedCallback(name: string, _oldValue: string, newValue: string) {\n      if (name === 'query') {\n        console.log('query', newValue);\n      }\n    }\n}","import Picker from './picker.js'\nimport Database from './database.js'\nexport { Picker, Database }\n","import Database from './database.js';\n\n// via https://unpkg.com/browse/emojibase-data@6.0.0/meta/groups.json\nconst allGroups = [\n  [-1, '', 'custom'],\n  [0, '', 'smileys-emotion'],\n  [1, '', 'people-body'],\n  [3, '', 'animals-nature'],\n  [4, '', 'food-drink'],\n  [5, '', 'travel-places'],\n  [6, '', 'activities'],\n  [7, '', 'objects'],\n  [8, '', 'symbols'],\n  [9, '', 'flags']\n].map(([id, emoji, name]) => ({ id, emoji, name }));\n\nconst groups = allGroups.slice(1);\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\nconst NUM_SKIN_TONES = 6;\n\n/* istanbul ignore next */\nconst rIC = typeof requestIdleCallback === 'function' ? requestIdleCallback : setTimeout;\n\n// check for ZWJ (zero width joiner) character\nfunction hasZwj (emoji) {\n  return emoji.unicode.includes('\\u200d')\n}\n\n// Find one good representative emoji from each version to test by checking its color.\n// Ideally it should have color in the center. For some inspiration, see:\n// https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n//\n// Note that for certain versions (12.1, 13.1), there is no point in testing them explicitly, because\n// all the emoji from this version are compound-emoji from previous versions. So they would pass a color\n// test, even in browsers that display them as double emoji. (E.g. \"face in clouds\" might render as\n// \"face without mouth\" plus \"fog\".) These emoji can only be filtered using the width test,\n// which happens in checkZwjSupport.js.\nconst versionsAndTestEmoji = {\n  '': 15.1, // shaking head, technically from v15 but see note above\n  '': 14,\n  '': 13.1, // smiling face with tear, technically from v13 but see note above\n  '': 12.1, // sari, technically from v12 but see note above\n  '': 11,\n  '': 5,\n  '': 4,\n  '': 3,\n  '': 2,\n  '': 1,\n  '': 0.7,\n  '': 0.6\n};\n\nconst TIMEOUT_BEFORE_LOADING_MESSAGE = 1000; // 1 second\nconst DEFAULT_SKIN_TONE_EMOJI = '';\nconst DEFAULT_NUM_COLUMNS = 8;\n\n// Based on https://fivethirtyeight.com/features/the-100-most-used-emojis/ and\n// https://blog.emojipedia.org/facebook-reveals-most-and-least-used-emojis/ with\n// a bit of my own curation. (E.g. avoid the \"OK\" gesture because of connotations:\n// https://emojipedia.org/ok-hand/)\nconst MOST_COMMONLY_USED_EMOJI = [\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  ''\n];\n\n// It's important to list Twemoji Mozilla before everything else, because Mozilla bundles their\n// own font on some platforms (notably Windows and Linux as of this writing). Typically, Mozilla\n// updates faster than the underlying OS, and we don't want to render older emoji in one font and\n// newer emoji in another font:\n// https://github.com/nolanlawson/emoji-picker-element/pull/268#issuecomment-1073347283\nconst FONT_FAMILY = '\"Twemoji Mozilla\",\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",' +\n  '\"Noto Color Emoji\",\"EmojiOne Color\",\"Android Emoji\",sans-serif';\n\n/* istanbul ignore next */\nconst DEFAULT_CATEGORY_SORTING = (a, b) => a < b ? -1 : a > b ? 1 : 0;\n\n// Test if an emoji is supported by rendering it to canvas and checking that the color is not black\n// See https://about.gitlab.com/blog/2018/05/30/journey-in-native-unicode-emoji/\n// and https://www.npmjs.com/package/if-emoji for inspiration\n// This implementation is largely borrowed from if-emoji, adding the font-family\n\n\nconst getTextFeature = (text, color) => {\n  const canvas = document.createElement('canvas');\n  canvas.width = canvas.height = 1;\n\n  const ctx = canvas.getContext('2d');\n  ctx.textBaseline = 'top';\n  ctx.font = `100px ${FONT_FAMILY}`;\n  ctx.fillStyle = color;\n  ctx.scale(0.01, 0.01);\n  ctx.fillText(text, 0, 0);\n\n  return ctx.getImageData(0, 0, 1, 1).data\n};\n\nconst compareFeatures = (feature1, feature2) => {\n  const feature1Str = [...feature1].join(',');\n  const feature2Str = [...feature2].join(',');\n  // This is RGBA, so for 0,0,0, we are checking that the first RGB is not all zeroes.\n  // Most of the time when unsupported this is 0,0,0,0, but on Chrome on Mac it is\n  // 0,0,0,61 - there is a transparency here.\n  return feature1Str === feature2Str && !feature1Str.startsWith('0,0,0,')\n};\n\nfunction testColorEmojiSupported (text) {\n  // Render white and black and then compare them to each other and ensure they're the same\n  // color, and neither one is black. This shows that the emoji was rendered in color.\n  const feature1 = getTextFeature(text, '#000');\n  const feature2 = getTextFeature(text, '#fff');\n  return feature1 && feature2 && compareFeatures(feature1, feature2)\n}\n\n// rather than check every emoji ever, which would be expensive, just check some representatives from the\n// different emoji releases to determine what the font supports\n\nfunction determineEmojiSupportLevel () {\n  const entries = Object.entries(versionsAndTestEmoji);\n  try {\n    // start with latest emoji and work backwards\n    for (const [emoji, version] of entries) {\n      if (testColorEmojiSupported(emoji)) {\n        return version\n      }\n    }\n  } catch (e) { // canvas error\n  } finally {\n  }\n  // In case of an error, be generous and just assume all emoji are supported (e.g. for canvas errors\n  // due to anti-fingerprinting add-ons). Better to show some gray boxes than nothing at all.\n  return entries[0][1] // first one in the list is the most recent version\n}\n\n// Check which emojis we know for sure aren't supported, based on Unicode version level\nlet promise;\nconst detectEmojiSupportLevel = () => {\n  if (!promise) {\n    // Delay so it can run while the IDB database is being created by the browser (on another thread).\n    // This helps especially with first load  we want to start pre-populating the database on the main thread,\n    // and then wait for IDB to commit everything, and while waiting we run this check.\n    promise = new Promise(resolve => (\n      rIC(() => (\n        resolve(determineEmojiSupportLevel()) // delay so ideally this can run while IDB is first populating\n      ))\n    ));\n  }\n  return promise\n};\n// determine which emojis containing ZWJ (zero width joiner) characters\n// are supported (rendered as one glyph) rather than unsupported (rendered as two or more glyphs)\nconst supportedZwjEmojis = new Map();\n\nconst VARIATION_SELECTOR = '\\ufe0f';\nconst SKINTONE_MODIFIER = '\\ud83c';\nconst ZWJ = '\\u200d';\nconst LIGHT_SKIN_TONE = 0x1F3FB;\nconst LIGHT_SKIN_TONE_MODIFIER = 0xdffb;\n\n// TODO: this is a naive implementation, we can improve it later\n// It's only used for the skintone picker, so as long as people don't customize with\n// really exotic emoji then it should work fine\nfunction applySkinTone (str, skinTone) {\n  if (skinTone === 0) {\n    return str\n  }\n  const zwjIndex = str.indexOf(ZWJ);\n  if (zwjIndex !== -1) {\n    return str.substring(0, zwjIndex) +\n      String.fromCodePoint(LIGHT_SKIN_TONE + skinTone - 1) +\n      str.substring(zwjIndex)\n  }\n  if (str.endsWith(VARIATION_SELECTOR)) {\n    str = str.substring(0, str.length - 1);\n  }\n  return str + SKINTONE_MODIFIER + String.fromCodePoint(LIGHT_SKIN_TONE_MODIFIER + skinTone - 1)\n}\n\nfunction halt (event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\n// Implementation left/right or up/down navigation, circling back when you\n// reach the start/end of the list\nfunction incrementOrDecrement (decrement, val, arr) {\n  val += (decrement ? -1 : 1);\n  if (val < 0) {\n    val = arr.length - 1;\n  } else if (val >= arr.length) {\n    val = 0;\n  }\n  return val\n}\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\n// We don't need all the data on every emoji, and there are specific things we need\n// for the UI, so build a \"view model\" from the emoji object we got from the database\n\nfunction summarizeEmojisForUI (emojis, emojiSupportLevel) {\n  const toSimpleSkinsMap = skins => {\n    const res = {};\n    for (const skin of skins) {\n      // ignore arrays like [1, 2] with multiple skin tones\n      // also ignore variants that are in an unsupported emoji version\n      // (these do exist - variants from a different version than their base emoji)\n      if (typeof skin.tone === 'number' && skin.version <= emojiSupportLevel) {\n        res[skin.tone] = skin.unicode;\n      }\n    }\n    return res\n  };\n\n  return emojis.map(({ unicode, skins, shortcodes, url, name, category, annotation }) => ({\n    unicode,\n    name,\n    shortcodes,\n    url,\n    category,\n    annotation,\n    id: unicode || name,\n    skins: skins && toSimpleSkinsMap(skins)\n  }))\n}\n\n// import rAF from one place so that the bundle size is a bit smaller\nconst rAF = requestAnimationFrame;\n\n// Svelte action to calculate the width of an element and auto-update\n// using ResizeObserver. If ResizeObserver is unsupported, we just use rAF once\n// and don't bother to update.\n\n\nlet resizeObserverSupported = typeof ResizeObserver === 'function';\n\nfunction calculateWidth (node, abortSignal, onUpdate) {\n  let resizeObserver;\n  if (resizeObserverSupported) {\n    resizeObserver = new ResizeObserver(entries => (\n      onUpdate(entries[0].contentRect.width)\n    ));\n    resizeObserver.observe(node);\n  } else { // just set the width once, don't bother trying to track it\n    rAF(() => (\n      onUpdate(node.getBoundingClientRect().width)\n    ));\n  }\n\n  // cleanup function (called on destroy)\n  abortSignal.addEventListener('abort', () => {\n    if (resizeObserver) {\n      resizeObserver.disconnect();\n    }\n  });\n}\n\n// get the width of the text inside of a DOM node, via https://stackoverflow.com/a/59525891/680742\nfunction calculateTextWidth (node) {\n  /* istanbul ignore else */\n  {\n    const range = document.createRange();\n    range.selectNode(node.firstChild);\n    return range.getBoundingClientRect().width\n  }\n}\n\nlet baselineEmojiWidth;\n\nfunction checkZwjSupport (zwjEmojisToCheck, baselineEmoji, emojiToDomNode) {\n  for (const emoji of zwjEmojisToCheck) {\n    const domNode = emojiToDomNode(emoji);\n    const emojiWidth = calculateTextWidth(domNode);\n    if (typeof baselineEmojiWidth === 'undefined') { // calculate the baseline emoji width only once\n      baselineEmojiWidth = calculateTextWidth(baselineEmoji);\n    }\n    // On Windows, some supported emoji are ~50% bigger than the baseline emoji, but what we really want to guard\n    // against are the ones that are 2x the size, because those are truly broken (person with red hair = person with\n    // floating red wig, black cat = cat with black square, polar bear = bear with snowflake, etc.)\n    // So here we set the threshold at 1.8 times the size of the baseline emoji.\n    const supported = emojiWidth / 1.8 < baselineEmojiWidth;\n    supportedZwjEmojis.set(emoji.unicode, supported);\n  }\n}\n\n// like lodash's uniq\n\nfunction uniq (arr) {\n  return uniqBy(arr, _ => _)\n}\n\n// Note we put this in its own function outside Picker.js to avoid Svelte doing an invalidation on the \"setter\" here.\n// At best the invalidation is useless, at worst it can cause infinite loops:\n// https://github.com/nolanlawson/emoji-picker-element/pull/180\n// https://github.com/sveltejs/svelte/issues/6521\n// Also note tabpanelElement can be null if the element is disconnected immediately after connected\nfunction resetScrollTopIfPossible (element) {\n  /* istanbul ignore else */\n  if (element) { // Makes me nervous not to have this `if` guard\n    element.scrollTop = 0;\n  }\n}\n\nfunction getFromMap (cache, key, func) {\n  let cached = cache.get(key);\n  if (!cached) {\n    cached = func();\n    cache.set(key, cached);\n  }\n  return cached\n}\n\nfunction toString (value) {\n  return '' + value\n}\n\nfunction parseTemplate (htmlString) {\n  const template = document.createElement('template');\n  template.innerHTML = htmlString;\n  return template\n}\n\nconst parseCache = new WeakMap();\nconst domInstancesCache = new WeakMap();\n// This needs to be a symbol because it needs to be different from any possible output of a key function\nconst unkeyedSymbol = Symbol('un-keyed');\n\n// Not supported in Safari <=13\nconst hasReplaceChildren = 'replaceChildren' in Element.prototype;\nfunction replaceChildren (parentNode, newChildren) {\n  /* istanbul ignore else */\n  if (hasReplaceChildren) {\n    parentNode.replaceChildren(...newChildren);\n  } else { // minimal polyfill for Element.prototype.replaceChildren\n    parentNode.innerHTML = '';\n    parentNode.append(...newChildren);\n  }\n}\n\nfunction doChildrenNeedRerender (parentNode, newChildren) {\n  let oldChild = parentNode.firstChild;\n  let oldChildrenCount = 0;\n  // iterate using firstChild/nextSibling because browsers use a linked list under the hood\n  while (oldChild) {\n    const newChild = newChildren[oldChildrenCount];\n    // check if the old child and new child are the same\n    if (newChild !== oldChild) {\n      return true\n    }\n    oldChild = oldChild.nextSibling;\n    oldChildrenCount++;\n  }\n  // if new children length is different from old, we must re-render\n  return oldChildrenCount !== newChildren.length\n}\n\nfunction patchChildren (newChildren, instanceBinding) {\n  const { targetNode } = instanceBinding;\n  let { targetParentNode } = instanceBinding;\n\n  let needsRerender = false;\n\n  if (targetParentNode) { // already rendered once\n    needsRerender = doChildrenNeedRerender(targetParentNode, newChildren);\n  } else { // first render of list\n    needsRerender = true;\n    instanceBinding.targetNode = undefined; // placeholder node not needed anymore, free memory\n    instanceBinding.targetParentNode = targetParentNode = targetNode.parentNode;\n  }\n  // avoid re-rendering list if the dom nodes are exactly the same before and after\n  if (needsRerender) {\n    replaceChildren(targetParentNode, newChildren);\n  }\n}\n\nfunction patch (expressions, instanceBindings) {\n  for (const instanceBinding of instanceBindings) {\n    const {\n      targetNode,\n      currentExpression,\n      binding: {\n        expressionIndex,\n        attributeName,\n        attributeValuePre,\n        attributeValuePost\n      }\n    } = instanceBinding;\n\n    const expression = expressions[expressionIndex];\n\n    if (currentExpression === expression) {\n      // no need to update, same as before\n      continue\n    }\n\n    instanceBinding.currentExpression = expression;\n\n    if (attributeName) { // attribute replacement\n      targetNode.setAttribute(attributeName, attributeValuePre + toString(expression) + attributeValuePost);\n    } else { // text node / child element / children replacement\n      let newNode;\n      if (Array.isArray(expression)) { // array of DOM elements produced by tag template literals\n        patchChildren(expression, instanceBinding);\n      } else if (expression instanceof Element) { // html tag template returning a DOM element\n        newNode = expression;\n        targetNode.replaceWith(newNode);\n      } else { // primitive - string, number, etc\n        // nodeValue is faster than textContent supposedly https://www.youtube.com/watch?v=LY6y3HbDVmg\n        // note we may be replacing the value in a placeholder text node\n        targetNode.nodeValue = toString(expression);\n      }\n      if (newNode) {\n        instanceBinding.targetNode = newNode;\n      }\n    }\n  }\n}\n\nfunction parse (tokens) {\n  let htmlString = '';\n\n  let withinTag = false;\n  let withinAttribute = false;\n  let elementIndexCounter = -1; // depth-first traversal order\n\n  const elementsToBindings = new Map();\n  const elementIndexes = [];\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const token = tokens[i];\n    htmlString += token;\n\n    if (i === len - 1) {\n      break // no need to process characters - no more expressions to be found\n    }\n\n    for (let j = 0; j < token.length; j++) {\n      const char = token.charAt(j);\n      switch (char) {\n        case '<': {\n          const nextChar = token.charAt(j + 1);\n          if (nextChar === '/') { // closing tag\n            // leaving an element\n            elementIndexes.pop();\n          } else { // not a closing tag\n            withinTag = true;\n            elementIndexes.push(++elementIndexCounter);\n          }\n          break\n        }\n        case '>': {\n          withinTag = false;\n          withinAttribute = false;\n          break\n        }\n        case '=': {\n          withinAttribute = true;\n          break\n        }\n      }\n    }\n\n    const elementIndex = elementIndexes[elementIndexes.length - 1];\n    const bindings = getFromMap(elementsToBindings, elementIndex, () => []);\n\n    let attributeName;\n    let attributeValuePre;\n    let attributeValuePost;\n    if (withinAttribute) {\n      // I never use single-quotes for attribute values in HTML, so just support double-quotes or no-quotes\n      const match = /(\\S+)=\"?([^\"=]*)$/.exec(token);\n      attributeName = match[1];\n      attributeValuePre = match[2];\n      attributeValuePost = /^[^\">]*/.exec(tokens[i + 1])[0];\n    }\n\n    const binding = {\n      attributeName,\n      attributeValuePre,\n      attributeValuePost,\n      expressionIndex: i\n    };\n\n    bindings.push(binding);\n\n    if (!withinTag && !withinAttribute) {\n      // Add a placeholder text node, so we can find it later. Note we only support one dynamic child text node\n      htmlString += ' ';\n    }\n  }\n\n  const template = parseTemplate(htmlString);\n\n  return {\n    template,\n    elementsToBindings\n  }\n}\n\nfunction traverseAndSetupBindings (dom, elementsToBindings) {\n  const instanceBindings = [];\n  // traverse dom\n  const treeWalker = document.createTreeWalker(dom, NodeFilter.SHOW_ELEMENT);\n\n  let element = dom;\n  let elementIndex = -1;\n  do {\n    const bindings = elementsToBindings.get(++elementIndex);\n    if (bindings) {\n      for (let i = 0; i < bindings.length; i++) {\n        const binding = bindings[i];\n\n        const targetNode = binding.attributeName\n          ? element // attribute binding, just use the element itself\n          : element.firstChild; // not an attribute binding, so has a placeholder text node\n\n        const instanceBinding = {\n          binding,\n          targetNode,\n          targetParentNode: undefined,\n          currentExpression: undefined\n        };\n\n        instanceBindings.push(instanceBinding);\n      }\n    }\n  } while ((element = treeWalker.nextNode()))\n\n  return instanceBindings\n}\n\nfunction parseHtml (tokens) {\n  // All templates and bound expressions are unique per tokens array\n  const { template, elementsToBindings } = getFromMap(parseCache, tokens, () => parse(tokens));\n\n  // When we parseHtml, we always return a fresh DOM instance ready to be updated\n  const dom = template.cloneNode(true).content.firstElementChild;\n  const instanceBindings = traverseAndSetupBindings(dom, elementsToBindings);\n\n  return function updateDomInstance (expressions) {\n    patch(expressions, instanceBindings);\n    return dom\n  }\n}\n\nfunction createFramework (state) {\n  const domInstances = getFromMap(domInstancesCache, state, () => new Map());\n  let domInstanceCacheKey = unkeyedSymbol;\n\n  function html (tokens, ...expressions) {\n    // Each unique lexical usage of map() is considered unique due to the html`` tagged template call it makes,\n    // which has lexically unique tokens. The unkeyed symbol is just used for html`` usage outside of a map().\n    const domInstancesForTokens = getFromMap(domInstances, tokens, () => new Map());\n    const updateDomInstance = getFromMap(domInstancesForTokens, domInstanceCacheKey, () => parseHtml(tokens));\n\n    return updateDomInstance(expressions) // update with expressions\n  }\n\n  function map (array, callback, keyFunction) {\n    return array.map((item, index) => {\n      const originalCacheKey = domInstanceCacheKey;\n      domInstanceCacheKey = keyFunction(item);\n      try {\n        return callback(item, index)\n      } finally {\n        domInstanceCacheKey = originalCacheKey;\n      }\n    })\n  }\n\n  return { map, html }\n}\n\nfunction render (container, state, helpers, events, actions, refs, abortSignal, firstRender) {\n  const { labelWithSkin, titleForEmoji, unicodeWithSkin } = helpers;\n  const { html, map } = createFramework(state);\n\n  function emojiList (emojis, searchMode, prefix) {\n    return map(emojis, (emoji, i) => {\n      return html`<button role=\"${searchMode ? 'option' : 'menuitem'}\" aria-selected=\"${state.searchMode ? i === state.activeSearchItem : ''}\" aria-label=\"${labelWithSkin(emoji, state.currentSkinTone)}\" title=\"${titleForEmoji(emoji)}\" class=\"emoji ${searchMode && i === state.activeSearchItem ? 'active' : ''}\" id=\"${`${prefix}-${emoji.id}`}\">${\n        emoji.unicode\n          ? unicodeWithSkin(emoji, state.currentSkinTone)\n          : html`<img class=\"custom-emoji\" src=\"${emoji.url}\" alt=\"\" loading=\"lazy\">`\n      }</button>`\n      // It's important for the cache key to be unique based on the prefix, because the framework caches based on the\n      // unique tokens + cache key, and the same emoji may be used in the tab as well as in the fav bar\n    }, emoji => `${prefix}-${emoji.id}`)\n  }\n\n  const section = () => {\n    return html`<section data-ref=\"rootElement\" class=\"picker\" aria-label=\"${state.i18n.regionLabel}\" style=\"${state.pickerStyle}\"><div class=\"pad-top\"></div><div class=\"search-row\"><div class=\"search-wrapper\"><input id=\"search\" class=\"search\" type=\"search\" role=\"combobox\" enterkeyhint=\"search\" placeholder=\"${state.i18n.searchLabel}\" autocapitalize=\"none\" autocomplete=\"off\" spellcheck=\"true\" aria-expanded=\"${!!(state.searchMode && state.currentEmojis.length)}\" aria-controls=\"search-results\" aria-describedby=\"search-description\" aria-autocomplete=\"list\" aria-activedescendant=\"${state.activeSearchItemId ? `emo-${state.activeSearchItemId}` : ''}\" data-ref=\"searchElement\" data-on-input=\"onSearchInput\" data-on-keydown=\"onSearchKeydown\"><label class=\"sr-only\" for=\"search\">${state.i18n.searchLabel}</label> <span id=\"search-description\" class=\"sr-only\">${state.i18n.searchDescription}</span></div><div class=\"skintone-button-wrapper ${state.skinTonePickerExpandedAfterAnimation ? 'expanded' : ''}\"><button id=\"skintone-button\" class=\"emoji ${state.skinTonePickerExpanded ? 'hide-focus' : ''}\" aria-label=\"${state.skinToneButtonLabel}\" title=\"${state.skinToneButtonLabel}\" aria-describedby=\"skintone-description\" aria-haspopup=\"listbox\" aria-expanded=\"${state.skinTonePickerExpanded}\" aria-controls=\"skintone-list\" data-on-click=\"onClickSkinToneButton\">${state.skinToneButtonText}</button></div><span id=\"skintone-description\" class=\"sr-only\">${state.i18n.skinToneDescription}</span><div data-ref=\"skinToneDropdown\" id=\"skintone-list\" class=\"skintone-list hide-focus ${state.skinTonePickerExpanded ? '' : 'hidden no-animate'}\" style=\"transform:translateY(${state.skinTonePickerExpanded ? 0 : 'calc(-1 * var(--num-skintones) * var(--total-emoji-size))'})\" role=\"listbox\" aria-label=\"${state.i18n.skinTonesLabel}\" aria-activedescendant=\"skintone-${state.activeSkinTone}\" aria-hidden=\"${!state.skinTonePickerExpanded}\" tabIndex=\"-1\" data-on-focusout=\"onSkinToneOptionsFocusOut\" data-on-click=\"onSkinToneOptionsClick\" data-on-keydown=\"onSkinToneOptionsKeydown\" data-on-keyup=\"onSkinToneOptionsKeyup\">${\n    map(state.skinTones, (skinTone, i) => {\n    return html`<div id=\"skintone-${i}\" class=\"emoji ${i === state.activeSkinTone ? 'active' : ''}\" aria-selected=\"${i === state.activeSkinTone}\" role=\"option\" title=\"${state.i18n.skinTones[i]}\" aria-label=\"${state.i18n.skinTones[i]}\">${skinTone}</div>`\n    }, skinTone => skinTone)\n        }</div></div><div class=\"nav\" role=\"tablist\" style=\"grid-template-columns:repeat(${state.groups.length},1fr)\" aria-label=\"${state.i18n.categoriesLabel}\" data-on-keydown=\"onNavKeydown\" data-on-click=\"onNavClick\">${\n            map(state.groups, (group) => {\n              return html`<button role=\"tab\" class=\"nav-button\" aria-controls=\"tab-${group.id}\" aria-label=\"${state.i18n.categories[group.name]}\" aria-selected=\"${!state.searchMode && state.currentGroup.id === group.id}\" title=\"${state.i18n.categories[group.name]}\" data-group-id=\"${group.id}\"><div class=\"nav-emoji emoji\">${group.emoji}</div></button>`\n            }, group => group.id)\n          }</div><div class=\"indicator-wrapper\"><div class=\"indicator\" style=\"transform:translateX(${(/* istanbul ignore next */ (state.isRtl ? -1 : 1)) * state.currentGroupIndex * 100}%)\"></div></div><div class=\"message ${state.message ? '' : 'gone'}\" role=\"alert\" aria-live=\"polite\">${state.message}</div><div data-ref=\"tabpanelElement\" class=\"tabpanel ${(!state.databaseLoaded || state.message) ? 'gone' : ''}\" role=\"${state.searchMode ? 'region' : 'tabpanel'}\" aria-label=\"${state.searchMode ? state.i18n.searchResultsLabel : state.i18n.categories[state.currentGroup.name]}\" id=\"${state.searchMode ? '' : `tab-${state.currentGroup.id}`}\" tabIndex=\"0\" data-on-click=\"onEmojiClick\"><div data-action=\"calculateEmojiGridStyle\">${\n              map(state.currentEmojisWithCategories, (emojiWithCategory, i) => {\n                return html`<div><div id=\"menu-label-${i}\" class=\"category ${state.currentEmojisWithCategories.length === 1 && state.currentEmojisWithCategories[0].category === '' ? 'gone' : ''}\" aria-hidden=\"true\">${\n                  state.searchMode\n                    ? state.i18n.searchResultsLabel\n                    : (\n                      emojiWithCategory.category\n                        ? emojiWithCategory.category\n                        : (\n                          state.currentEmojisWithCategories.length > 1\n                            ? state.i18n.categories.custom\n                            : state.i18n.categories[state.currentGroup.name]\n                        )\n                    )\n                }</div><div class=\"emoji-menu\" role=\"${state.searchMode ? 'listbox' : 'menu'}\" aria-labelledby=\"menu-label-${i}\" id=\"${state.searchMode ? 'search-results' : ''}\">${\n              emojiList(emojiWithCategory.emojis, state.searchMode, /* prefix */ 'emo')\n            }</div></div>`\n              }, emojiWithCategory => emojiWithCategory.category)\n            }</div></div><div class=\"favorites emoji-menu ${state.message ? 'gone' : ''}\" role=\"menu\" aria-label=\"${state.i18n.favoritesLabel}\" style=\"padding-inline-end:${`${state.scrollbarWidth}px`}\" data-on-click=\"onEmojiClick\">${\n            emojiList(state.currentFavorites, /* searchMode */ false, /* prefix */ 'fav')\n          }</div><button data-ref=\"baselineEmoji\" aria-hidden=\"true\" tabindex=\"-1\" class=\"abs-pos hidden emoji baseline-emoji\"></button></section>`\n  };\n\n  const rootDom = section();\n\n  if (firstRender) { // not a re-render\n    container.appendChild(rootDom);\n\n    // we only bind events/refs/actions once - there is no need to find them again given this component structure\n\n    // helper for traversing the dom, finding elements by an attribute, and getting the attribute value\n    const forElementWithAttribute = (attributeName, callback) => {\n      for (const element of container.querySelectorAll(`[${attributeName}]`)) {\n        callback(element, element.getAttribute(attributeName));\n      }\n    };\n\n    // bind events\n    for (const eventName of ['click', 'focusout', 'input', 'keydown', 'keyup']) {\n      forElementWithAttribute(`data-on-${eventName}`, (element, listenerName) => {\n        element.addEventListener(eventName, events[listenerName]);\n      });\n    }\n\n    // find refs\n    forElementWithAttribute('data-ref', (element, ref) => {\n      refs[ref] = element;\n    });\n\n    // set up actions\n    forElementWithAttribute('data-action', (element, action) => {\n      actions[action](element);\n    });\n\n    // destroy/abort logic\n    abortSignal.addEventListener('abort', () => {\n      container.removeChild(rootDom);\n    });\n  }\n}\n\n/* istanbul ignore next */\nconst qM = typeof queueMicrotask === 'function' ? queueMicrotask : callback => Promise.resolve().then(callback);\n\nfunction createState (abortSignal) {\n  let destroyed = false;\n  let currentObserver;\n\n  const propsToObservers = new Map();\n  const dirtyObservers = new Set();\n\n  let queued;\n\n  const flush = () => {\n    if (destroyed) {\n      return\n    }\n    const observersToRun = [...dirtyObservers];\n    dirtyObservers.clear(); // clear before running to force any new updates to run in another tick of the loop\n    try {\n      for (const observer of observersToRun) {\n        observer();\n      }\n    } finally {\n      queued = false;\n      if (dirtyObservers.size) { // new updates, queue another one\n        queued = true;\n        qM(flush);\n      }\n    }\n  };\n\n  const state = new Proxy({}, {\n    get (target, prop) {\n      if (currentObserver) {\n        let observers = propsToObservers.get(prop);\n        if (!observers) {\n          observers = new Set();\n          propsToObservers.set(prop, observers);\n        }\n        observers.add(currentObserver);\n      }\n      return target[prop]\n    },\n    set (target, prop, newValue) {\n      target[prop] = newValue;\n      const observers = propsToObservers.get(prop);\n      if (observers) {\n        for (const observer of observers) {\n          dirtyObservers.add(observer);\n        }\n        if (!queued) {\n          queued = true;\n          qM(flush);\n        }\n      }\n      return true\n    }\n  });\n\n  const createEffect = (callback) => {\n    const runnable = () => {\n      const oldObserver = currentObserver;\n      currentObserver = runnable;\n      try {\n        return callback()\n      } finally {\n        currentObserver = oldObserver;\n      }\n    };\n    return runnable()\n  };\n\n  // destroy logic\n  abortSignal.addEventListener('abort', () => {\n    destroyed = true;\n  });\n\n  return {\n    state,\n    createEffect\n  }\n}\n\n// Compare two arrays, with a function called on each item in the two arrays that returns true if the items are equal\nfunction arraysAreEqualByFunction (left, right, areEqualFunc) {\n  if (left.length !== right.length) {\n    return false\n  }\n  for (let i = 0; i < left.length; i++) {\n    if (!areEqualFunc(left[i], right[i])) {\n      return false\n    }\n  }\n  return true\n}\n\n/* eslint-disable prefer-const,no-labels,no-inner-declarations */\n\n// constants\nconst EMPTY_ARRAY = [];\n\nconst { assign } = Object;\n\nfunction createRoot (shadowRoot, props) {\n  const refs = {};\n  const abortController = new AbortController();\n  const abortSignal = abortController.signal;\n  const { state, createEffect } = createState(abortSignal);\n\n  // initial state\n  assign(state, {\n    skinToneEmoji: undefined,\n    i18n: undefined,\n    database: undefined,\n    customEmoji: undefined,\n    customCategorySorting: undefined,\n    emojiVersion: undefined\n  });\n\n  // public props\n  assign(state, props);\n\n  // private props\n  assign(state, {\n    initialLoad: true,\n    currentEmojis: [],\n    currentEmojisWithCategories: [],\n    rawSearchText: '',\n    searchText: '',\n    searchMode: false,\n    activeSearchItem: -1,\n    message: undefined,\n    skinTonePickerExpanded: false,\n    skinTonePickerExpandedAfterAnimation: false,\n    currentSkinTone: 0,\n    activeSkinTone: 0,\n    skinToneButtonText: undefined,\n    pickerStyle: undefined,\n    skinToneButtonLabel: '',\n    skinTones: [],\n    currentFavorites: [],\n    defaultFavoriteEmojis: undefined,\n    numColumns: DEFAULT_NUM_COLUMNS,\n    isRtl: false,\n    scrollbarWidth: 0,\n    currentGroupIndex: 0,\n    groups: groups,\n    databaseLoaded: false,\n    activeSearchItemId: undefined\n  });\n\n  //\n  // Update the current group based on the currentGroupIndex\n  //\n  createEffect(() => {\n    if (state.currentGroup !== state.groups[state.currentGroupIndex]) {\n      state.currentGroup = state.groups[state.currentGroupIndex];\n    }\n  });\n\n  //\n  // Utils/helpers\n  //\n\n  const focus = id => {\n    shadowRoot.getElementById(id).focus();\n  };\n\n  const emojiToDomNode = emoji => shadowRoot.getElementById(`emo-${emoji.id}`);\n\n  // fire a custom event that crosses the shadow boundary\n  const fireEvent = (name, detail) => {\n    refs.rootElement.dispatchEvent(new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      composed: true\n    }));\n  };\n\n  //\n  // Comparison utils\n  //\n\n  const compareEmojiArrays = (a, b) => a.id === b.id;\n\n  const compareCurrentEmojisWithCategories = (a, b) => {\n    const { category: aCategory, emojis: aEmojis } = a;\n    const { category: bCategory, emojis: bEmojis } = b;\n\n    if (aCategory !== bCategory) {\n      return false\n    }\n\n    return arraysAreEqualByFunction(aEmojis, bEmojis, compareEmojiArrays)\n  };\n\n  //\n  // Update utils to avoid excessive re-renders\n  //\n\n  // avoid excessive re-renders by checking the value before setting\n  const updateCurrentEmojis = (newEmojis) => {\n    if (!arraysAreEqualByFunction(state.currentEmojis, newEmojis, compareEmojiArrays)) {\n      state.currentEmojis = newEmojis;\n    }\n  };\n\n  // avoid excessive re-renders\n  const updateSearchMode = (newSearchMode) => {\n    if (state.searchMode !== newSearchMode) {\n      state.searchMode = newSearchMode;\n    }\n  };\n\n  // avoid excessive re-renders\n  const updateCurrentEmojisWithCategories = (newEmojisWithCategories) => {\n    if (!arraysAreEqualByFunction(state.currentEmojisWithCategories, newEmojisWithCategories, compareCurrentEmojisWithCategories)) {\n      state.currentEmojisWithCategories = newEmojisWithCategories;\n    }\n  };\n\n  // Helpers used by PickerTemplate\n\n  const unicodeWithSkin = (emoji, currentSkinTone) => (\n    (currentSkinTone && emoji.skins && emoji.skins[currentSkinTone]) || emoji.unicode\n  );\n\n  const labelWithSkin = (emoji, currentSkinTone) => (\n    uniq([\n      (emoji.name || unicodeWithSkin(emoji, currentSkinTone)),\n      emoji.annotation,\n      ...(emoji.shortcodes || EMPTY_ARRAY)\n    ].filter(Boolean)).join(', ')\n  );\n\n  const titleForEmoji = (emoji) => (\n    emoji.annotation || (emoji.shortcodes || EMPTY_ARRAY).join(', ')\n  );\n\n  const helpers = {\n    labelWithSkin, titleForEmoji, unicodeWithSkin\n  };\n  const events = {\n    onClickSkinToneButton,\n    onEmojiClick,\n    onNavClick,\n    onNavKeydown,\n    onSearchKeydown,\n    onSkinToneOptionsClick,\n    onSkinToneOptionsFocusOut,\n    onSkinToneOptionsKeydown,\n    onSkinToneOptionsKeyup,\n    onSearchInput\n  };\n  const actions = {\n    calculateEmojiGridStyle\n  };\n\n  let firstRender = true;\n  createEffect(() => {\n    render(shadowRoot, state, helpers, events, actions, refs, abortSignal, firstRender);\n    firstRender = false;\n  });\n\n  //\n  // Determine the emoji support level (in requestIdleCallback)\n  //\n\n  // mount logic\n  if (!state.emojiVersion) {\n    detectEmojiSupportLevel().then(level => {\n      // Can't actually test emoji support in Jest/Vitest/JSDom, emoji never render in color in Cairo\n      /* istanbul ignore next */\n      if (!level) {\n        state.message = state.i18n.emojiUnsupportedMessage;\n      }\n    });\n  }\n\n  //\n  // Set or update the database object\n  //\n\n  createEffect(() => {\n    // show a Loading message if it takes a long time, or show an error if there's a network/IDB error\n    async function handleDatabaseLoading () {\n      let showingLoadingMessage = false;\n      const timeoutHandle = setTimeout(() => {\n        showingLoadingMessage = true;\n        state.message = state.i18n.loadingMessage;\n      }, TIMEOUT_BEFORE_LOADING_MESSAGE);\n      try {\n        await state.database.ready();\n        state.databaseLoaded = true; // eslint-disable-line no-unused-vars\n      } catch (err) {\n        console.error(err);\n        state.message = state.i18n.networkErrorMessage;\n      } finally {\n        clearTimeout(timeoutHandle);\n        if (showingLoadingMessage) { // Seems safer than checking the i18n string, which may change\n          showingLoadingMessage = false;\n          state.message = ''; // eslint-disable-line no-unused-vars\n        }\n      }\n    }\n\n    if (state.database) {\n      /* no await */\n      handleDatabaseLoading();\n    }\n  });\n\n  //\n  // Global styles for the entire picker\n  //\n\n  createEffect(() => {\n    state.pickerStyle = `\n      --num-groups: ${state.groups.length}; \n      --indicator-opacity: ${state.searchMode ? 0 : 1}; \n      --num-skintones: ${NUM_SKIN_TONES};`;\n  });\n\n  //\n  // Set or update the customEmoji\n  //\n\n  createEffect(() => {\n    if (state.customEmoji && state.database) {\n      updateCustomEmoji(); // re-run whenever customEmoji change\n    }\n  });\n\n  createEffect(() => {\n    if (state.customEmoji && state.customEmoji.length) {\n      if (state.groups !== allGroups) { // don't update unnecessarily\n        state.groups = allGroups;\n      }\n    } else if (state.groups !== groups) {\n      if (state.currentGroupIndex) {\n        // If the current group is anything other than \"custom\" (which is first), decrement.\n        // This fixes the odd case where you set customEmoji, then pick a category, then unset customEmoji\n        state.currentGroupIndex--;\n      }\n      state.groups = groups;\n    }\n  });\n\n  //\n  // Set or update the preferred skin tone\n  //\n\n  createEffect(() => {\n    async function updatePreferredSkinTone () {\n      if (state.databaseLoaded) {\n        state.currentSkinTone = await state.database.getPreferredSkinTone();\n      }\n    }\n\n    /* no await */ updatePreferredSkinTone();\n  });\n\n  createEffect(() => {\n    state.skinTones = Array(NUM_SKIN_TONES).fill().map((_, i) => applySkinTone(state.skinToneEmoji, i));\n  });\n\n  createEffect(() => {\n    state.skinToneButtonText = state.skinTones[state.currentSkinTone];\n  });\n\n  createEffect(() => {\n    state.skinToneButtonLabel = state.i18n.skinToneLabel.replace('{skinTone}', state.i18n.skinTones[state.currentSkinTone]);\n  });\n\n  //\n  // Set or update the favorites emojis\n  //\n\n  createEffect(() => {\n    async function updateDefaultFavoriteEmojis () {\n      const { database } = state;\n      const favs = (await Promise.all(MOST_COMMONLY_USED_EMOJI.map(unicode => (\n        database.getEmojiByUnicodeOrName(unicode)\n      )))).filter(Boolean); // filter because in Jest/Vitest tests we don't have all the emoji in the DB\n      state.defaultFavoriteEmojis = favs;\n    }\n\n    if (state.databaseLoaded) {\n      /* no await */ updateDefaultFavoriteEmojis();\n    }\n  });\n\n  function updateCustomEmoji () {\n    // Certain effects have an implicit dependency on customEmoji since it affects the database\n    // Getting it here on the state ensures this effect re-runs when customEmoji change.\n    // Setting it on the database is pointless but prevents this code from being removed by a minifier.\n    state.database.customEmoji = state.customEmoji || EMPTY_ARRAY;\n  }\n\n  createEffect(() => {\n    async function updateFavorites () {\n      updateCustomEmoji(); // re-run whenever customEmoji change\n      const { database, defaultFavoriteEmojis, numColumns } = state;\n      const dbFavorites = await database.getTopFavoriteEmoji(numColumns);\n      const favorites = await summarizeEmojis(uniqBy([\n        ...dbFavorites,\n        ...defaultFavoriteEmojis\n      ], _ => (_.unicode || _.name)).slice(0, numColumns));\n      state.currentFavorites = favorites;\n    }\n\n    if (state.databaseLoaded && state.defaultFavoriteEmojis) {\n      /* no await */ updateFavorites();\n    }\n  });\n\n  //\n  // Calculate the width of the emoji grid. This serves two purposes:\n  // 1) Re-calculate the --num-columns var because it may have changed\n  // 2) Re-calculate the scrollbar width because it may have changed\n  //   (i.e. because the number of items changed)\n  // 3) Re-calculate whether we're in RTL mode or not.\n  //\n  // The benefit of doing this in one place is to align with rAF/ResizeObserver\n  // and do all the calculations in one go. RTL vs LTR is not strictly width-related,\n  // but since we're already reading the style here, and since it's already aligned with\n  // the rAF loop, this is the most appropriate place to do it perf-wise.\n  //\n\n  function calculateEmojiGridStyle (node) {\n    calculateWidth(node, abortSignal, width => {\n      /* istanbul ignore next */\n      { // jsdom throws errors for this kind of fancy stuff\n        // read all the style/layout calculations we need to make\n        const style = getComputedStyle(refs.rootElement);\n        const newNumColumns = parseInt(style.getPropertyValue('--num-columns'), 10);\n        const newIsRtl = style.getPropertyValue('direction') === 'rtl';\n        const parentWidth = node.parentElement.getBoundingClientRect().width;\n        const newScrollbarWidth = parentWidth - width;\n\n        // write to state variables\n        state.numColumns = newNumColumns;\n        state.scrollbarWidth = newScrollbarWidth; // eslint-disable-line no-unused-vars\n        state.isRtl = newIsRtl; // eslint-disable-line no-unused-vars\n      }\n    });\n  }\n\n  //\n  // Set or update the currentEmojis. Check for invalid ZWJ renderings\n  // (i.e. double emoji).\n  //\n\n  createEffect(() => {\n    async function updateEmojis () {\n      const { searchText, currentGroup, databaseLoaded, customEmoji } = state;\n      if (!databaseLoaded) {\n        state.currentEmojis = [];\n        state.searchMode = false;\n      } else if (searchText.length >= MIN_SEARCH_TEXT_LENGTH) {\n        const newEmojis = await getEmojisBySearchQuery(searchText);\n        if (state.searchText === searchText) { // if the situation changes asynchronously, do not update\n          updateCurrentEmojis(newEmojis);\n          updateSearchMode(true);\n        }\n      } else { // database is loaded and we're not in search mode, so we're in normal category mode\n        const { id: currentGroupId } = currentGroup;\n        // avoid race condition where currentGroupId is -1 and customEmoji is undefined/empty\n        if (currentGroupId !== -1 || (customEmoji && customEmoji.length)) {\n          const newEmojis = await getEmojisByGroup(currentGroupId);\n          if (state.currentGroup.id === currentGroupId) { // if the situation changes asynchronously, do not update\n            updateCurrentEmojis(newEmojis);\n            updateSearchMode(false);\n          }\n        }\n      }\n    }\n\n    /* no await */ updateEmojis();\n  });\n\n  // Some emojis have their ligatures rendered as two or more consecutive emojis\n  // We want to treat these the same as unsupported emojis, so we compare their\n  // widths against the baseline widths and remove them as necessary\n  createEffect(() => {\n    const { currentEmojis, emojiVersion } = state;\n    const zwjEmojisToCheck = currentEmojis\n      .filter(emoji => emoji.unicode) // filter custom emoji\n      .filter(emoji => hasZwj(emoji) && !supportedZwjEmojis.has(emoji.unicode));\n    if (!emojiVersion && zwjEmojisToCheck.length) {\n      // render now, check their length later\n      updateCurrentEmojis(currentEmojis);\n      rAF(() => checkZwjSupportAndUpdate(zwjEmojisToCheck));\n    } else {\n      const newEmojis = emojiVersion ? currentEmojis : currentEmojis.filter(isZwjSupported);\n      updateCurrentEmojis(newEmojis);\n      // Reset scroll top to 0 when emojis change\n      rAF(() => resetScrollTopIfPossible(refs.tabpanelElement));\n    }\n  });\n\n  function checkZwjSupportAndUpdate (zwjEmojisToCheck) {\n    checkZwjSupport(zwjEmojisToCheck, refs.baselineEmoji, emojiToDomNode);\n    // force update\n    // eslint-disable-next-line no-self-assign\n    state.currentEmojis = state.currentEmojis;\n  }\n\n  function isZwjSupported (emoji) {\n    return !emoji.unicode || !hasZwj(emoji) || supportedZwjEmojis.get(emoji.unicode)\n  }\n\n  async function filterEmojisByVersion (emojis) {\n    const emojiSupportLevel = state.emojiVersion || await detectEmojiSupportLevel();\n    // !version corresponds to custom emoji\n    return emojis.filter(({ version }) => !version || version <= emojiSupportLevel)\n  }\n\n  async function summarizeEmojis (emojis) {\n    return summarizeEmojisForUI(emojis, state.emojiVersion || await detectEmojiSupportLevel())\n  }\n\n  async function getEmojisByGroup (group) {\n    // -1 is custom emoji\n    const emoji = group === -1 ? state.customEmoji : await state.database.getEmojiByGroup(group);\n    return summarizeEmojis(await filterEmojisByVersion(emoji))\n  }\n\n  async function getEmojisBySearchQuery (query) {\n    return summarizeEmojis(await filterEmojisByVersion(await state.database.getEmojiBySearchQuery(query)))\n  }\n\n  createEffect(() => {\n  });\n\n  //\n  // Derive currentEmojisWithCategories from currentEmojis. This is always done even if there\n  // are no categories, because it's just easier to code the HTML this way.\n  //\n\n  createEffect(() => {\n    function calculateCurrentEmojisWithCategories () {\n      const { searchMode, currentEmojis } = state;\n      if (searchMode) {\n        return [\n          {\n            category: '',\n            emojis: currentEmojis\n          }\n        ]\n      }\n      const categoriesToEmoji = new Map();\n      for (const emoji of currentEmojis) {\n        const category = emoji.category || '';\n        let emojis = categoriesToEmoji.get(category);\n        if (!emojis) {\n          emojis = [];\n          categoriesToEmoji.set(category, emojis);\n        }\n        emojis.push(emoji);\n      }\n      return [...categoriesToEmoji.entries()]\n        .map(([category, emojis]) => ({ category, emojis }))\n        .sort((a, b) => state.customCategorySorting(a.category, b.category))\n    }\n\n    const newEmojisWithCategories = calculateCurrentEmojisWithCategories();\n    updateCurrentEmojisWithCategories(newEmojisWithCategories);\n  });\n\n  //\n  // Handle active search item (i.e. pressing up or down while searching)\n  //\n\n  createEffect(() => {\n    state.activeSearchItemId = state.activeSearchItem !== -1 && state.currentEmojis[state.activeSearchItem].id;\n  });\n\n  //\n  // Handle user input on the search input\n  //\n\n  createEffect(() => {\n    const { rawSearchText } = state;\n    rIC(() => {\n      state.searchText = (rawSearchText || '').trim(); // defer to avoid input delays, plus we can trim here\n      state.activeSearchItem = -1;\n    });\n  });\n\n  function onSearchKeydown (event) {\n    if (!state.searchMode || !state.currentEmojis.length) {\n      return\n    }\n\n    const goToNextOrPrevious = (previous) => {\n      halt(event);\n      state.activeSearchItem = incrementOrDecrement(previous, state.activeSearchItem, state.currentEmojis);\n    };\n\n    switch (event.key) {\n      case 'ArrowDown':\n        return goToNextOrPrevious(false)\n      case 'ArrowUp':\n        return goToNextOrPrevious(true)\n      case 'Enter':\n        if (state.activeSearchItem === -1) {\n          // focus the first option in the list since the list must be non-empty at this point (it's verified above)\n          state.activeSearchItem = 0;\n        } else { // there is already an active search item\n          halt(event);\n          return clickEmoji(state.currentEmojis[state.activeSearchItem].id)\n        }\n    }\n  }\n\n  //\n  // Handle user input on nav\n  //\n\n  function onNavClick (event) {\n    const { target } = event;\n    const closestTarget = target.closest('.nav-button');\n    /* istanbul ignore if */\n    if (!closestTarget) {\n      return // This should never happen, but makes me nervous not to have it\n    }\n    const groupId = parseInt(closestTarget.dataset.groupId, 10);\n    refs.searchElement.value = ''; // clear search box input\n    state.rawSearchText = '';\n    state.searchText = '';\n    state.activeSearchItem = -1;\n    state.currentGroupIndex = state.groups.findIndex(_ => _.id === groupId);\n  }\n\n  function onNavKeydown (event) {\n    const { target, key } = event;\n\n    const doFocus = el => {\n      if (el) {\n        halt(event);\n        el.focus();\n      }\n    };\n\n    switch (key) {\n      case 'ArrowLeft':\n        return doFocus(target.previousElementSibling)\n      case 'ArrowRight':\n        return doFocus(target.nextElementSibling)\n      case 'Home':\n        return doFocus(target.parentElement.firstElementChild)\n      case 'End':\n        return doFocus(target.parentElement.lastElementChild)\n    }\n  }\n\n  //\n  // Handle user input on an emoji\n  //\n\n  async function clickEmoji (unicodeOrName) {\n    const emoji = await state.database.getEmojiByUnicodeOrName(unicodeOrName);\n    const emojiSummary = [...state.currentEmojis, ...state.currentFavorites]\n      .find(_ => (_.id === unicodeOrName));\n    const skinTonedUnicode = emojiSummary.unicode && unicodeWithSkin(emojiSummary, state.currentSkinTone);\n    await state.database.incrementFavoriteEmojiCount(unicodeOrName);\n    fireEvent('emoji-click', {\n      emoji,\n      skinTone: state.currentSkinTone,\n      ...(skinTonedUnicode && { unicode: skinTonedUnicode }),\n      ...(emojiSummary.name && { name: emojiSummary.name })\n    });\n  }\n\n  async function onEmojiClick (event) {\n    const { target } = event;\n    /* istanbul ignore if */\n    if (!target.classList.contains('emoji')) {\n      // This should never happen, but makes me nervous not to have it\n      return\n    }\n    halt(event);\n    const id = target.id.substring(4); // replace 'emo-' or 'fav-' prefix\n\n    /* no await */ clickEmoji(id);\n  }\n\n  //\n  // Handle user input on the skintone picker\n  //\n\n  function changeSkinTone (skinTone) {\n    state.currentSkinTone = skinTone;\n    state.skinTonePickerExpanded = false;\n    focus('skintone-button');\n    fireEvent('skin-tone-change', { skinTone });\n    /* no await */ state.database.setPreferredSkinTone(skinTone);\n  }\n\n  function onSkinToneOptionsClick (event) {\n    const { target: { id } } = event;\n    const match = id && id.match(/^skintone-(\\d)/); // skintone option format\n    /* istanbul ignore if */\n    if (!match) { // not a skintone option\n      return // This should never happen, but makes me nervous not to have it\n    }\n    halt(event);\n    const skinTone = parseInt(match[1], 10); // remove 'skintone-' prefix\n    changeSkinTone(skinTone);\n  }\n\n  function onClickSkinToneButton (event) {\n    state.skinTonePickerExpanded = !state.skinTonePickerExpanded;\n    state.activeSkinTone = state.currentSkinTone;\n    // this should always be true, since the button is obscured by the listbox, so this `if` is just to be sure\n    if (state.skinTonePickerExpanded) {\n      halt(event);\n      rAF(() => focus('skintone-list'));\n    }\n  }\n\n  // To make the animation nicer, change the z-index of the skintone picker button\n  // *after* the animation has played. This makes it appear that the picker box\n  // is expanding \"below\" the button\n  createEffect(() => {\n    if (state.skinTonePickerExpanded) {\n      refs.skinToneDropdown.addEventListener('transitionend', () => {\n        state.skinTonePickerExpandedAfterAnimation = true; // eslint-disable-line no-unused-vars\n      }, { once: true });\n    } else {\n      state.skinTonePickerExpandedAfterAnimation = false; // eslint-disable-line no-unused-vars\n    }\n  });\n\n  function onSkinToneOptionsKeydown (event) {\n    // this should never happen, but makes me nervous not to have it\n    /* istanbul ignore if */\n    if (!state.skinTonePickerExpanded) {\n      return\n    }\n    const changeActiveSkinTone = async nextSkinTone => {\n      halt(event);\n      state.activeSkinTone = nextSkinTone;\n    };\n\n    switch (event.key) {\n      case 'ArrowUp':\n        return changeActiveSkinTone(incrementOrDecrement(true, state.activeSkinTone, state.skinTones))\n      case 'ArrowDown':\n        return changeActiveSkinTone(incrementOrDecrement(false, state.activeSkinTone, state.skinTones))\n      case 'Home':\n        return changeActiveSkinTone(0)\n      case 'End':\n        return changeActiveSkinTone(state.skinTones.length - 1)\n      case 'Enter':\n        // enter on keydown, space on keyup. this is just how browsers work for buttons\n        // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n        halt(event);\n        return changeSkinTone(state.activeSkinTone)\n      case 'Escape':\n        halt(event);\n        state.skinTonePickerExpanded = false;\n        return focus('skintone-button')\n    }\n  }\n\n  function onSkinToneOptionsKeyup (event) {\n    // this should never happen, but makes me nervous not to have it\n    /* istanbul ignore if */\n    if (!state.skinTonePickerExpanded) {\n      return\n    }\n    switch (event.key) {\n      case ' ':\n        // enter on keydown, space on keyup. this is just how browsers work for buttons\n        // https://lists.w3.org/Archives/Public/w3c-wai-ig/2019JanMar/0086.html\n        halt(event);\n        return changeSkinTone(state.activeSkinTone)\n    }\n  }\n\n  async function onSkinToneOptionsFocusOut (event) {\n    // On blur outside of the skintone listbox, collapse the skintone picker.\n    const { relatedTarget } = event;\n    // The `else` should never happen, but makes me nervous not to have it\n    /* istanbul ignore else */\n    if (!relatedTarget || relatedTarget.id !== 'skintone-list') {\n      state.skinTonePickerExpanded = false;\n    }\n  }\n\n  function onSearchInput (event) {\n    state.rawSearchText = event.target.value;\n  }\n\n  return {\n    $set (newState) {\n      assign(state, newState);\n    },\n    $destroy () {\n      abortController.abort();\n    }\n  }\n}\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\nvar enI18n = {\n  categoriesLabel: 'Categories',\n  emojiUnsupportedMessage: 'Your browser does not support color emoji.',\n  favoritesLabel: 'Favorites',\n  loadingMessage: 'Loading',\n  networkErrorMessage: 'Could not load emoji.',\n  regionLabel: 'Emoji picker',\n  searchDescription: 'When search results are available, press up or down to select and enter to choose.',\n  searchLabel: 'Search',\n  searchResultsLabel: 'Search results',\n  skinToneDescription: 'When expanded, press up or down to select and enter to choose.',\n  skinToneLabel: 'Choose a skin tone (currently {skinTone})',\n  skinTonesLabel: 'Skin tones',\n  skinTones: [\n    'Default',\n    'Light',\n    'Medium-Light',\n    'Medium',\n    'Medium-Dark',\n    'Dark'\n  ],\n  categories: {\n    custom: 'Custom',\n    'smileys-emotion': 'Smileys and emoticons',\n    'people-body': 'People and body',\n    'animals-nature': 'Animals and nature',\n    'food-drink': 'Food and drink',\n    'travel-places': 'Travel and places',\n    activities: 'Activities',\n    objects: 'Objects',\n    symbols: 'Symbols',\n    flags: 'Flags'\n  }\n};\n\nvar baseStyles = \":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){color-scheme:light;--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{color-scheme:dark;--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--emoji-font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}\";\n\nconst PROPS = [\n  'customEmoji',\n  'customCategorySorting',\n  'database',\n  'dataSource',\n  'i18n',\n  'locale',\n  'skinToneEmoji',\n  'emojiVersion'\n];\n\n// Styles injected ourselves, so we can declare the FONT_FAMILY variable in one place\nconst EXTRA_STYLES = `:host{--emoji-font-family:${FONT_FAMILY}}`;\n\nclass PickerElement extends HTMLElement {\n  constructor (props) {\n    super();\n    this.attachShadow({ mode: 'open' });\n    const style = document.createElement('style');\n    style.textContent = baseStyles + EXTRA_STYLES;\n    this.shadowRoot.appendChild(style);\n    this._ctx = {\n      // Set defaults\n      locale: DEFAULT_LOCALE,\n      dataSource: DEFAULT_DATA_SOURCE,\n      skinToneEmoji: DEFAULT_SKIN_TONE_EMOJI,\n      customCategorySorting: DEFAULT_CATEGORY_SORTING,\n      customEmoji: null,\n      i18n: enI18n,\n      emojiVersion: null,\n      ...props\n    };\n    // Handle properties set before the element was upgraded\n    for (const prop of PROPS) {\n      if (prop !== 'database' && Object.prototype.hasOwnProperty.call(this, prop)) {\n        this._ctx[prop] = this[prop];\n        delete this[prop];\n      }\n    }\n    this._dbFlush(); // wait for a flush before creating the db, in case the user calls e.g. a setter or setAttribute\n  }\n\n  connectedCallback () {\n    // The _cmp may be defined if the component was immediately disconnected and then reconnected. In that case,\n    // do nothing (preserve the state)\n    if (!this._cmp) {\n      this._cmp = createRoot(this.shadowRoot, this._ctx);\n    }\n  }\n\n  disconnectedCallback () {\n    // Check in a microtask if the element is still connected. If so, treat this as a \"move\" rather than a disconnect\n    // Inspired by Vue: https://vuejs.org/guide/extras/web-components.html#building-custom-elements-with-vue\n    qM(() => {\n      // this._cmp may be defined if connect-disconnect-connect-disconnect occurs synchronously\n      if (!this.isConnected && this._cmp) {\n        this._cmp.$destroy();\n        this._cmp = undefined;\n\n        const { database } = this._ctx;\n        database.close()\n          // only happens if the database failed to load in the first place, so we don't care\n          .catch(err => console.error(err));\n      }\n    });\n  }\n\n  static get observedAttributes () {\n    return ['locale', 'data-source', 'skin-tone-emoji', 'emoji-version'] // complex objects aren't supported, also use kebab-case\n  }\n\n  attributeChangedCallback (attrName, oldValue, newValue) {\n    this._set(\n      // convert from kebab-case to camelcase\n      // see https://github.com/sveltejs/svelte/issues/3852#issuecomment-665037015\n      attrName.replace(/-([a-z])/g, (_, up) => up.toUpperCase()),\n      // convert string attribute to float if necessary\n      attrName === 'emoji-version' ? parseFloat(newValue) : newValue\n    );\n  }\n\n  _set (prop, newValue) {\n    this._ctx[prop] = newValue;\n    if (this._cmp) {\n      this._cmp.$set({ [prop]: newValue });\n    }\n    if (['locale', 'dataSource'].includes(prop)) {\n      this._dbFlush();\n    }\n  }\n\n  _dbCreate () {\n    const { locale, dataSource, database } = this._ctx;\n    // only create a new database if we really need to\n    if (!database || database.locale !== locale || database.dataSource !== dataSource) {\n      this._set('database', new Database({ locale, dataSource }));\n    }\n  }\n\n  // Update the Database in one microtask if the locale/dataSource change. We do one microtask\n  // so we don't create two Databases if e.g. both the locale and the dataSource change\n  _dbFlush () {\n    qM(() => (\n      this._dbCreate()\n    ));\n  }\n}\n\nconst definitions = {};\n\nfor (const prop of PROPS) {\n  definitions[prop] = {\n    get () {\n      if (prop === 'database') {\n        // in rare cases, the microtask may not be flushed yet, so we need to instantiate the DB\n        // now if the user is asking for it\n        this._dbCreate();\n      }\n      return this._ctx[prop]\n    },\n    set (val) {\n      if (prop === 'database') {\n        throw new Error('database is read-only')\n      }\n      this._set(prop, val);\n    }\n  };\n}\n\nObject.defineProperties(PickerElement.prototype, definitions);\n\n/* istanbul ignore else */\nif (!customElements.get('emoji-picker')) { // if already defined, do nothing (e.g. same script imported twice)\n  customElements.define('emoji-picker', PickerElement);\n}\n\nexport { PickerElement as default };\n","function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openIndexedDBRequests = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openIndexedDBRequests[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openIndexedDBRequests[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openIndexedDBRequests[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(//g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n//\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\nconst isFirefoxContentScript = typeof wrappedJSObject !== 'undefined';\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  // if inside a Firefox content script, need to clone the emoji object to prevent Firefox from complaining about\n  // cross-origin object. See: https://github.com/nolanlawson/emoji-picker-element/issues/356\n  /* istanbul ignore if */\n  if (isFirefoxContentScript) {\n    emoji = structuredClone(emoji);\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n// even with --excludePrivate \\_()_/\n/** @private */\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  let inBuffer = binaryStringToArrayBuffer(inString);\n\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n"],"names":["$be550d328187eb94$var$promise","$be550d328187eb94$var$baselineEmojiWidth","$6bcec25060dd6e92$export$395e24b9a277a1da","HTMLElement","query","constructor","attachShadow","mode","connectedCallback","callback","timeoutId","shadowRoot","innerHTML","input","querySelector","handleMouseMove","dispatchEvent","CustomEvent","detail","value","args","window","clearTimeout","setTimeout","apply","addEventListener","focus","textbox","$7c9734ca8f93e03f$var$template","document","createElement","$7c9734ca8f93e03f$export$46209ca0040d6ae6","appendChild","content","cloneNode","$a4d41102f2c043db$export$bc00d4d99d9c6e7d","parse","getAttribute","Intl","NumberFormat","toString","base","r","parseInt","Number","isNaN","parseFloat","observedAttributes","accept","test","elmentName","attributeChangedCallback","name","_oldValue","newValue","console","log","$f19b912d87716459$var$assertNonEmptyString","str","Error","$f19b912d87716459$var$assertNumber","number","$f19b912d87716459$var$STORE_EMOJI","$f19b912d87716459$var$STORE_KEYVALUE","$f19b912d87716459$var$STORE_FAVORITES","$f19b912d87716459$var$INDEX_TOKENS","$f19b912d87716459$var$INDEX_COUNT","$f19b912d87716459$var$INDEX_GROUP_AND_ORDER","$f19b912d87716459$var$KEY_ETAG","$f19b912d87716459$var$KEY_PREFERRED_SKINTONE","$f19b912d87716459$var$MODE_READONLY","$f19b912d87716459$var$MODE_READWRITE","$f19b912d87716459$var$INDEX_SKIN_UNICODE","$f19b912d87716459$var$uniqEmoji","emojis","$f19b912d87716459$var$uniqBy","arr","func","set","Set","res","item","key","has","add","push","_","unicode","$f19b912d87716459$var$openIndexedDBRequests","$f19b912d87716459$var$databaseCache","$f19b912d87716459$var$onCloseListeners","$f19b912d87716459$var$handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","$f19b912d87716459$var$createDatabase","dbName","db","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","$f19b912d87716459$var$initialMigration","createObjectStore","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","onclose","$f19b912d87716459$var$closeDatabase","$f19b912d87716459$var$dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","$f19b912d87716459$var$irregularEmoticons","$f19b912d87716459$var$extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","$f19b912d87716459$var$normalizeTokens","length","$f19b912d87716459$var$callStore","method","target","$f19b912d87716459$var$getIDB","$f19b912d87716459$var$getAllIDB","$f19b912d87716459$var$commit","commit","$f19b912d87716459$var$findCommonMembers","arrays","uniqByFunc","shortestArray","$f19b912d87716459$var$minBy","array","minItem","i","results","some","findIndex","$f19b912d87716459$var$isEmpty","$f19b912d87716459$var$get","$f19b912d87716459$var$hasData","url","eTag","oldETag","oldUrl","all","$f19b912d87716459$var$doFullDatabaseScanForSingleResult","predicate","emojiStore","lastKey","processNextBatch","getAll","IDBKeyRange","lowerBound","$f19b912d87716459$var$loadData","emojiData","transformedData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","tone","skinTones","skinUnicodes","skinVersions","metaStore","todo","checkFetched","onFetched","data","clear","put","$f19b912d87716459$var$getEmojiByGroup","range","bound","index","$f19b912d87716459$var$getEmojiBySearchQuery","intermediateResults","checkDone","onDone","a","b","token","only","$f19b912d87716459$var$getEmojiByShortcode","shortcode","lowerShortcodes","includes","$f19b912d87716459$var$getEmojiByUnicode","$f19b912d87716459$var$requiredKeys$1","$f19b912d87716459$var$customEmojiIndex","customEmojis","$f19b912d87716459$var$assertCustomEmojis","isArray","Array","firstItemIsFaulty","sortByName","searchTrie","$f19b912d87716459$var$trie","itemToTokens","Map","currentMap","char","charAt","nextMap","get","valuesAtCoda","exact","queue","shift","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","search","byShortcode","byName","$f19b912d87716459$var$isFirefoxContentScript","wrappedJSObject","$f19b912d87716459$var$cleanEmoji","structuredClone","len","$f19b912d87716459$var$warnETag","warn","$f19b912d87716459$var$requiredKeys","$f19b912d87716459$var$assertStatus","response","dataSource","Math","floor","status","$f19b912d87716459$var$getETag","fetch","headers","$f19b912d87716459$var$getETagAndData","json","$f19b912d87716459$var$assertEmojiData","$f19b912d87716459$var$jsonChecksum","object","inBuffer","$f19b912d87716459$var$binaryStringToArrayBuffer","binary","buf","ArrayBuffer","Uint8Array","charCodeAt","JSON","stringify","btoa","$f19b912d87716459$var$arrayBufferToBinaryString","buffer","bytes","byteLength","String","fromCharCode","crypto","subtle","digest","$f19b912d87716459$var$checkForUpdates","eTagAndData","$f19b912d87716459$var$loadDataForFirstTime","$f19b912d87716459$export$2e2bcd8739ae039","locale","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","ready","checkReady","getEmojiByGroup","getEmojiBySearchQuery","getEmojiByShortcode","getEmojiByUnicodeOrName","unicodeOrName","getPreferredSkinTone","setPreferredSkinTone","skinTone","incrementFavoriteEmojiCount","getTopFavoriteEmoji","limit","customEmojiIndex","favoritesStore","openCursor","cursor","addResult","continue","primaryKey","custom","_shutdown","err","delete","deleteDatabase","$be550d328187eb94$var$allGroups","id","$be550d328187eb94$var$groups","slice","$be550d328187eb94$var$rIC","requestIdleCallback","$be550d328187eb94$var$hasZwj","$be550d328187eb94$var$versionsAndTestEmoji","$be550d328187eb94$var$MOST_COMMONLY_USED_EMOJI","$be550d328187eb94$var$FONT_FAMILY","$be550d328187eb94$var$DEFAULT_CATEGORY_SORTING","$be550d328187eb94$var$getTextFeature","text","color","canvas","width","height","ctx","getContext","textBaseline","font","fillStyle","scale","fillText","getImageData","$be550d328187eb94$var$compareFeatures","feature1","feature2","feature1Str","join","startsWith","$be550d328187eb94$var$detectEmojiSupportLevel","$be550d328187eb94$var$determineEmojiSupportLevel","$be550d328187eb94$var$testColorEmojiSupported","$be550d328187eb94$var$supportedZwjEmojis","$be550d328187eb94$var$halt","event","preventDefault","stopPropagation","$be550d328187eb94$var$incrementOrDecrement","decrement","val","$be550d328187eb94$var$uniqBy","$be550d328187eb94$var$rAF","requestAnimationFrame","$be550d328187eb94$var$resizeObserverSupported","ResizeObserver","$be550d328187eb94$var$calculateTextWidth","node","createRange","selectNode","firstChild","getBoundingClientRect","$be550d328187eb94$var$getFromMap","cache","cached","$be550d328187eb94$var$parseCache","WeakMap","$be550d328187eb94$var$domInstancesCache","$be550d328187eb94$var$unkeyedSymbol","Symbol","$be550d328187eb94$var$hasReplaceChildren","Element","prototype","$be550d328187eb94$var$qM","queueMicrotask","then","$be550d328187eb94$var$arraysAreEqualByFunction","left","right","areEqualFunc","$be550d328187eb94$var$EMPTY_ARRAY","assign","$be550d328187eb94$var$assign","$be550d328187eb94$var$enI18n","categoriesLabel","emojiUnsupportedMessage","favoritesLabel","loadingMessage","networkErrorMessage","regionLabel","searchDescription","searchLabel","searchResultsLabel","skinToneDescription","skinToneLabel","skinTonesLabel","categories","activities","objects","symbols","flags","$be550d328187eb94$var$PROPS","$be550d328187eb94$var$EXTRA_STYLES","$be550d328187eb94$export$2e2bcd8739ae039","props","style","prop","textContent","$be550d328187eb94$var$baseStyles","_ctx","skinToneEmoji","customCategorySorting","i18n","emojiVersion","hasOwnProperty","call","_dbFlush","_cmp","$be550d328187eb94$var$createRoot","refs","abortController","AbortController","abortSignal","signal","state","createEffect","$be550d328187eb94$var$createState","currentObserver","queued","destroyed","propsToObservers","dirtyObservers","flush","observersToRun","observer","size","Proxy","observers","runnable","oldObserver","database","initialLoad","currentEmojis","currentEmojisWithCategories","rawSearchText","searchText","searchMode","activeSearchItem","message","skinTonePickerExpanded","skinTonePickerExpandedAfterAnimation","currentSkinTone","activeSkinTone","skinToneButtonText","pickerStyle","skinToneButtonLabel","currentFavorites","defaultFavoriteEmojis","numColumns","isRtl","scrollbarWidth","currentGroupIndex","groups","databaseLoaded","activeSearchItemId","currentGroup","getElementById","emojiToDomNode","fireEvent","rootElement","bubbles","composed","compareEmojiArrays","compareCurrentEmojisWithCategories","category","aCategory","aEmojis","bCategory","bEmojis","updateCurrentEmojis","newEmojis","updateSearchMode","newSearchMode","updateCurrentEmojisWithCategories","newEmojisWithCategories","unicodeWithSkin","helpers","labelWithSkin","$be550d328187eb94$var$uniq","titleForEmoji","events","onClickSkinToneButton","onEmojiClick","onNavClick","closestTarget","closest","groupId","dataset","searchElement","onNavKeydown","doFocus","el","previousElementSibling","nextElementSibling","parentElement","firstElementChild","lastElementChild","onSearchKeydown","goToNextOrPrevious","previous","clickEmoji","onSkinToneOptionsClick","changeSkinTone","onSkinToneOptionsFocusOut","onSkinToneOptionsKeydown","changeActiveSkinTone","nextSkinTone","onSkinToneOptionsKeyup","onSearchInput","actions","calculateEmojiGridStyle","onUpdate","resizeObserver","getComputedStyle","newNumColumns","getPropertyValue","newIsRtl","parentWidth","contentRect","observe","disconnect","firstRender","updateCustomEmoji","isZwjSupported","filterEmojisByVersion","emojiSupportLevel","summarizeEmojis","$be550d328187eb94$var$summarizeEmojisForUI","toSimpleSkinsMap","skin","getEmojisByGroup","getEmojisBySearchQuery","emojiSummary","find","skinTonedUnicode","classList","contains","substring","relatedTarget","$be550d328187eb94$var$render","container","html","$be550d328187eb94$var$createFramework","domInstances","domInstanceCacheKey","keyFunction","originalCacheKey","expressions","domInstancesForTokens","updateDomInstance","$be550d328187eb94$var$parseHtml","template","elementsToBindings","$be550d328187eb94$var$parse","htmlString","withinTag","withinAttribute","elementIndexCounter","elementIndexes","attributeName","attributeValuePre","attributeValuePost","j","nextChar","pop","bindings","exec","binding","expressionIndex","$be550d328187eb94$var$parseTemplate","dom","instanceBindings","$be550d328187eb94$var$traverseAndSetupBindings","treeWalker","createTreeWalker","NodeFilter","SHOW_ELEMENT","element","elementIndex","targetNode","instanceBinding","targetParentNode","currentExpression","nextNode","$be550d328187eb94$var$patch","expression","setAttribute","newNode","$be550d328187eb94$var$patchChildren","newChildren","needsRerender","$be550d328187eb94$var$doChildrenNeedRerender","parentNode","oldChild","oldChildrenCount","newChild","nextSibling","$be550d328187eb94$var$replaceChildren","replaceChildren","append","replaceWith","nodeValue","emojiList","prefix","rootDom","emojiWithCategory","forElementWithAttribute","querySelectorAll","eventName","listenerName","ref","action","removeChild","level","handleDatabaseLoading","showingLoadingMessage","timeoutHandle","updatePreferredSkinTone","fill","$be550d328187eb94$var$applySkinTone","zwjIndex","indexOf","fromCodePoint","$be550d328187eb94$var$LIGHT_SKIN_TONE","endsWith","$be550d328187eb94$var$LIGHT_SKIN_TONE_MODIFIER","updateDefaultFavoriteEmojis","favs","updateFavorites","dbFavorites","favorites","updateEmojis","currentGroupId","zwjEmojisToCheck","$be550d328187eb94$var$checkZwjSupport","baselineEmoji","emojiWidth","supported","tabpanelElement","scrollTop","calculateCurrentEmojisWithCategories","categoriesToEmoji","trim","skinToneDropdown","once","$set","newState","$destroy","abort","disconnectedCallback","isConnected","catch","attrName","oldValue","_set","up","toUpperCase","_dbCreate","$be550d328187eb94$var$definitions","defineProperties","customElements","define","$67f00a23dbf3c100$export$74572fb7c2eaec8c","defaultWhenEmpty","responses","lastChild","box","tool","p","navigator","clipboard","writeText","$f43313d21d3fd8e2$var$responses","ev"],"version":3,"file":"index.a35c9996.js.map"}